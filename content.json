{"meta":{"title":"JL's Blog","subtitle":"Never quit and never stop","description":"前端,Hexo,技术","author":"Sun JL","url":"https://forevehg.github.io"},"pages":[{"title":"Vue3变化记录","date":"2020-11-30T10:13:27.000Z","updated":"2025-03-16T23:21:39.753Z","comments":true,"path":"cache/Vue3变化记录.html","permalink":"https://forevehg.github.io/cache/Vue3变化记录.html","excerpt":"","text":"1. GlobalAPI2.x 中所有 vue 实例共享全局 api 和全局配置，给单元测试造成了困难，3.0 中添加新的全局 api，createApp Vue.prototype替换成config.globalProperties // before - Vue 2 Vue.prototype.$http = () => {}; // after - Vue 3 const app = Vue.createApp({}); app.config.globalProperties.$http = () => {}; 以此类推，2.x 中其他挂在 Vue 中的属性都要改为挂在 app(Vue.createApp())上 2. data组件的 data 选项在 vue2.x 时可以定义为对象或函数返回一个对象，在 3.0 中，只接受函数返回对象 3.0 中组件的 data 与 mixins 或 extends 中的 data 合并时执行浅合并 const Mixin = { data() { return { user: { name: 'Jack', id: 1, }, }; }, }; const CompA = { mixins: [Mixin], data() { return { user: { id: 2, }, }; }, }; //vue2.x的结果 { user: { id: 2, name: 'Jack' } } //vue3的结果 { user: { id: 2 } } 3. v-model1. 绑定变化2.x 默认绑定props -&gt; value,event -&gt; input, 3.0 改为props -&gt; modelValue,event -&gt; update:modelValue; &lt;ChildComponent v-model=\"pageTitle\" /> &lt;!-- would be shorthand for: --> &lt;ChildComponent :modelValue=\"pageTitle\" @update:modelValue=\"pageTitle = $event\" /> 2. 弃用了.sync 修饰符，用 v-model 代替3. 可以在同一个组件上多次使用 v-model&lt;ChildComponent v-model:title=\"pageTitle\" v-model:content=\"pageContent\" /> &lt;!-- would be shorthand for: --> &lt;ChildComponent :title=\"pageTitle\" @update:title=\"pageTitle = $event\" :content=\"pageContent\" @update:content=\"pageContent = $event\" /> 可以添加自定义的 v-model 修饰符; &lt;ChildComponent v-model.capitalize=\"pageTitle\" /> const app = Vue.createApp({ data() { return { myText: '', }; }, }); app.component('my-component', { props: { modelValue: String, modelModifiers: { // default: () => ({}), }, }, emits: ['update:modelValue'], methods: { emitValue(e) { let value = e.target.value; if (this.modelModifiers.capitalize) { value = value.charAt(0).toUpperCase() + value.slice(1); } this.$emit('update:modelValue', value); }, }, template: `&lt;input type=\"text\" :value=\"modelValue\" @input=\"emitValue\">`, }); app.mount('#app'); 4. v-if v-for 在同一个元素上使用时优先级2.x 中 v-for 比 v-if 优先级大3.0 中 v-if 始终比 v-for 优先级大 5. key3.0 中 key 值的使用变化 1. &lt;template&gt; 标签上可以使用 keyv-for中可以直接将 key 添加到&lt;template&gt;标签上 &lt;template v-for=\"item in list\" :key=\"item.id\">&lt;/template> 2. v-if,v-else-if,v-elsev-if,v-else-if,v-else会自动添加唯一的 key 值，如果手动添加，key 值必须唯一 6. v-bind 的绑定顺序影响渲染结果2.x 中 v-bind 的单个属性将始终覆盖对象中的绑定 &lt;!-- template --> &lt;div id=\"red\" v-bind=\"{ id: 'blue' }\">&lt;/div> &lt;!-- result --> &lt;div id=\"red\">&lt;/div> 3.0 中 v-bind 的绑定顺序决定了如何合并 &lt;!-- template --> &lt;div id=\"red\" v-bind=\"{ id: 'blue' }\">&lt;/div> &lt;!-- result --> &lt;div id=\"blue\">&lt;/div> &lt;!-- template --> &lt;div v-bind=\"{ id: 'blue' }\" id=\"red\">&lt;/div> &lt;!-- result --> &lt;div id=\"red\">&lt;/div> 7. v-on2.x中的native修饰符的作用是监听组件根元素的原生事件3.x中移除了v-on.native修饰符，新增了一个emits选项,参考以下示例： child-view.vue文件 &lt;template> &lt;div style=\"height:200px; background:#eee;\">&lt;span @click=\"handleClick\">click&lt;/span>&lt;/div> &lt;/template> &lt;script> export default { emits: ['add'], //这样写在点击根元素div时就会自动触发父元素的click事件 //emits: ['add', 'click'], 这样写只有在点击span元素时handleClick事件触发,然后通过$emit触发父元素的click事件 methods: { handleClick() { this.$emit(\"click\") } } }; &lt;/script> parent-view.vue &lt;template> &lt;child-view :name=\"name\" @add=\"add\" @click=\"click\">&lt;/child-view> &lt;/template> 8. 事件名称和验证触发的事件与 props 的属性验证相似，emits 的值为对象时，可以添加事件验证 app.component('custom-form', { emits: { // No validation click: null, // Validate submit event submit: ({ email, password }) => { if (email &amp;&amp; password) { return true; } else { console.warn('Invalid submit event payload!'); return false; } }, }, methods: { submitForm() { this.$emit('submit', { email, password }); //正常触发 this.$emit('submit', {}); //Invalid submit event payload! }, }, }); 9. v-for 中 ref2.x 中 v-for 的列表中使用 ref 会自动创建一个数组，包含列表中每一项的$ref 属性，但在嵌套的 v-for 中，这一默认行为的含义很模糊 3.x 中取消了这一默认行为,参考下面的例子 &lt;template> &lt;div v-for=\"item in list\" :key=\"item\" :ref=\"setItemRef\">{{ item }}&lt;/div> &lt;/template> &lt;script> export default { data() { return { list: [1, 2, 3, 4, 5, 6], itemRefs: [], }; }, beforeUpdate() { this.itemRefs = []; }, methods: { setItemRef(ref) { this.itemRefs.push(ref); console.log(this.itemRefs) }, }, }; &lt;/script> 用composition api &lt;script setup> import {ref} from 'vue'; let list = ref([1, 2, 3, 4, 5, 6]); let itemRef = ref([]); const setItemRef = (ref) => itemRef.value.push(ref); &lt;/script> 10. 函数式组件2.x中的函数式组件主要有两个使用场景 —- 优化性能 —- 多个根节点 在3.x中，带状态的组件性能已优化，性能方便可以忽略不计，也已经支持多个根节点，所以大多数情况下使用带状态的组件就可以，只有在简单"},{"title":"写写刚走出校门的这两个多月","date":"2017-08-06T04:54:31.000Z","updated":"2025-03-17T06:20:57.626Z","comments":true,"path":"cache/写写刚走出校门的这两个月.html","permalink":"https://forevehg.github.io/cache/写写刚走出校门的这两个月.html","excerpt":"五月初答辩结束后，开始在网上投简历，那时候特别迷茫，完全不知道下一步该去哪儿，只确定了一点，绝不回家。来杭州的决定其实纯属偶然，现在想想是自己的冲动吧，只因为投了很多简历却没有反应，在五月底的一天突然收到杭州一家公司的面试邀请，让我当天下午就过去面试，","text":"五月初答辩结束后，开始在网上投简历，那时候特别迷茫，完全不知道下一步该去哪儿，只确定了一点，绝不回家。来杭州的决定其实纯属偶然，现在想想是自己的冲动吧，只因为投了很多简历却没有反应，在五月底的一天突然收到杭州一家公司的面试邀请，让我当天下午就过去面试， 石沉大海的简历终于有所反应让我瞬间有些激动，心里生出了想来试一试的冲动，就这样我跟公司约好了下周一面试，也就是三天后。我在当天晚上就买好了火车票，当时的想法简单，只是去面试一下试试，不行了再回学校来，我连东西都没有收拾，想背着一个小包就直接过去，可是室友的一番话惊醒了我，她说我们要毕业了，你去了还有回来的必要么，我们能在学校的时间不多了。是啊，我冷静下来，在学校的最后一些时间，还有很多杂事要处理，导师时不时还要找我们过去补些毕业前必须交齐的材料，何况6月8号，大四的宿舍就封了，我去了，什么时候回来呢？在一番思索后，我决定把学校的事情处理好之后，直接去杭州，之后几天，和几个还未离开的舍友把大家的书整理好卖掉，把一些还能用又带不走的东西拿到宿舍楼下，楼下是由我们这一届大四毕业生搞起来的二手市场，把这些东西友情价的卖给学弟学妹们，再把一些能寄到家的东西打包邮回家，送一些人走，再被一些人送走，我的大学生活就这样结束了。写到这里我眼睛里还是有了点儿泪，到底我作为女生，还是太容易掉眼泪。到杭州之后，住在一个高中同学这里，是很好的朋友，一直都有联系，因为有她的帮助，我的初来乍到没有经历什么艰辛，就是穷，有一天手机欠费了，我连充话费的十块钱都凑不够，从微信红包上转了5块，银行卡的最后余额还有3块，我却想不到哪儿还有钱了。在这个时候刚好我大学的上铺跟我聊天，她还在她实习的公司工作，已经转正，她问我现在还有钱么，我嘴硬了两句，就跟她说了实话，我们都刚刚还完学校的学费贷款，不然我也不至于这么穷，她比我稍好，当时给我转了500块钱，才让我能继续生活。找工作还算顺利，一天差不多总有一个面试的机会，有遇见很奇葩的，一群男生光着膀子在一个三居室里算是创业吧， 吃住一起，我进去后什么也不问我，直接说我这里有个问题，你看看原因，我第一次经历这样的事情，有点儿懵，我看了看他是说四个字体图标，有一个图标不会显示，让我把这个图标显示出来，我之前自己做些东西没用到字体图标，只是有些了解，还好看了一会儿之后知道怎么回事儿之后就给它改好了，他就让我到旁边去谈，还是说我没有经验不能直接上手干活对公司价值不大，然后又说他们现在创业阶段，要是我想要这工作也可以接受我试试，就是没有工资，管吃，我听了就明确的拒绝了，我虽然想快点儿找到工作，但还是不能接受没有工资的工作。还有一个让我后怕的是一个跟最近李文星事件很像的经历，同样也是电话面试，面试之后说等通知，然后告诉我公司在天津有一个项目需要我去出差两个月，两个月后再回到杭州来，我一听天津就心生警惕，因为还在学校时，就听老师说有几个上一届学长就是被骗到天津去传销，我留了个心眼跟他说我考虑一下就挂了电话，在宿舍的群里聊天的时候，跟她们说起这事儿，宿舍长竟然说她遇到了跟我一样的套路，我们两个一对，立马觉得这一定是传销，第二天他又给我打电话的时候，我直接跟他说我已经找到工作了，不会再去天津，直到看到李文星的事情时，我心里一阵后怕，还好当时足够警惕，还好虽然急于找工作但还很理智。就这样找了差不多半个月，来到了现在的公司里，说起来感觉当时面试时自己的表现并不好，出门后心态也很平和，还很高兴的想着这个公司离住的地方挺近，骑自行车就可以回去了，就一路走着一路找着小黄车，没想到小黄车没找到公司的电话就来了，是人事姐姐的，直接说面试通过了，问我什么时候能上班，我一瞬间有些懵，恩恩啊啊的应着就说了一个日子，挂了电话然意识到，我找到工作了。当时也没想过什么条件，什么也没想，只觉得有个工作就好，其他都好说，幸运的是，离住的地方近，除了单休之外一切都挺好，我开始上班了。工作算不上忙，只是刚开始做前端，我也没有前端的工作经验，有些手忙脚乱，在适应了一个星期后就习惯了这样的生活，陆陆续续收到舍友的消息，有辗转几个城市最终回家乡找到工作的，有在父母安排下进了类似事业单位比较安稳的，有在北京从试用期转正的，也有在上海终于确定了工作的，还有至今没有找到仍在努力的，毕业后我们有了不同的选择，或主动或者无奈，但都在自己的路上往前走了。我现在依然后悔我浪费了大学的几年时间，如果能好好学习，一定比现在更加从容，但我也感慨我已经足够幸运，毕业后没有去培训依然找到了自己想找的工作，入了行，虽然也有很困难的时候，但到底因为没有选择培训身上没有背上贷款，在大学四年里，通过助学金，奖学金，寒暑假打工，做兼职，在网络中心勤工俭学，学费贷款这些，在不问家里要钱的情况下上完的大学，说实话，我用大四实习的工资还上大学学费贷款的时候心里是有一些自豪的，至此我终于做到了在入学前做出的决定，整个大学里，我靠着自己终于过完了，虽然还完之后全身上下也就几百块钱了，但未来的事情未来再说吧，那一刻我就是这样想的。工作后，生活也都走上了正轨，我想着，只要我努力，会越来越好的。"},{"title":"所谓热爱，一想起就会眼眶发热--读全职高手","date":"2017-08-06T07:07:06.000Z","updated":"2020-05-17T13:56:06.000Z","comments":true,"path":"cache/所谓热爱，一想起就会眼眶发热-读全职高手.html","permalink":"https://forevehg.github.io/cache/所谓热爱，一想起就会眼眶发热-读全职高手.html","excerpt":"从初中开始我就有了看电子书的习惯，那时候是抱着一个滑盖的按键手机，屏幕很小，翻页还是靠音量键的上下键，高中后高一高二时除了上课时间几乎都抱着个手机看电子书，","text":"从初中开始我就有了看电子书的习惯，那时候是抱着一个滑盖的按键手机，屏幕很小，翻页还是靠音量键的上下键，高中后高一高二时除了上课时间几乎都抱着个手机看电子书，看的书很杂，都不是什么正儿八经有深度的书，算是娱乐，我不喜欢很多女生喜欢看的霸道总裁，灰姑娘变公主这样套路的言情小说，反而更喜欢看一些男生们看的，类似于坏蛋是怎样炼成的，斗破苍穹这些，好比一个小说阅读网站的男频，更和我胃口点儿，不过我看的最多的是耽美，在高三前看了很多耽美，也有很多喜欢的文，后来上了大学，有了智能手机，更方便了，我却发现很难静下心来看一本小说了，如果白天躺在宿舍里，心里常常会有自责感，所以宁愿自己忙碌起来，在大学四年我反而基本没有完整看完过小说了。全职高手我很早就被人推荐过，只是碍于我并不喜欢玩儿游戏，更不了解网游所以一直不喜欢网游文的原因一直没有去看，在今年四月，全职高手的动漫上线了，我又被基友安利，于是下定决心去看看，这一看就入了坑，在我看来，全职高手的动漫真的可以看做是目前国漫中的精品，无论是情节还是画面，值得一看。全职高手动漫吸引我之后，我决定去看看小说，我一向不喜欢主角叽叽歪歪谈了一整本恋爱的文，更喜欢整本描绘了一个完整的世界，故事有情节，主角有热血的小说，真巧，全职是这样的小说，上班之余，我用了一个月的时间一口气看完了，11M的小说读完最后一页我竟然觉得太短了，是我看过最长的小说，也是我最不舍得看完的小说全职高手从头到尾，只跟热爱有关，在全职中，我看到了一群人，他们对喜欢的游戏充满热血，哪怕电子竞技人的职业生涯非常有限，他们每个人都为自己热爱的东西拼尽全力。而我呢，我一向是个三分钟热度的人，所以我更加喜欢和羡慕他们，人一生如果能找到自己为之热爱和努力的东西，何其有幸啊。想想自己的行业，很多人吃的都是青春饭，那我能在这一行干多久呢，从大学一直到毕业，我从来没为自己设想过其他的路，我就要写代码，我就要进这一行，现在我不知道自己算不算进来了，勉强入门，那然后呢，就这么一只脚跨进门里，另一只脚还在门外吗，不是的，我想变得更好，我热爱这个东西吗，我想是的。"},{"title":"山与山从不相见，人与人总会重逢","date":"2018-05-09T12:35:08.000Z","updated":"2022-06-06T02:43:43.674Z","comments":true,"path":"cache/山与山从不相见，人与人总会重逢.html","permalink":"https://forevehg.github.io/cache/山与山从不相见，人与人总会重逢.html","excerpt":"清明节过后一周左右吧，和朋友去了宁波的象山，这是一趟计划了很久的旅程，我叫它毕业旅行。","text":"清明节过后一周左右吧，和朋友去了宁波的象山，这是一趟计划了很久的旅程，我叫它毕业旅行。从杭州坐动车到宁波，再从宁波坐大巴到象山，我在象山涌金广场找到了他们一起散过步的街道，找到了令在中感到疑惑的JJ麻辣烫的店，我走进去吃了一碗麻辣烫，不管他们是否吃过，就假装我get了一个同款吧，我就是想多留点念想，打了滴滴坐到他们住过的酒店，下车时突然刮风下雨，司机又把我扔在半路，伞快要被吹飞，我知道在中来的时候肯定车接车送，哪儿有我这么惨，但我仍忍不住想，我只是从临近的城市来到这里，在中是从另一个国家漂洋过海的来到这里，语言不通，路途也不熟悉，全凭着对一个人的信任就这么过来了，心里就忍不住感动，那天晚上我们四个在一起吃饭聊天，我很想让时间过的再慢一点，可是终究还是要过去，这两天结束的时候我坐在回程的车上，有点儿难过，就这么结束了吧，从此以后再也不喜欢你们了，我要努力过自己的生活了，后悔过吗？其实是有的，但从十四岁到二十四岁，这么多年既是追星也是相互陪伴，很多事情都历历在目，可太细腻的表现情感总觉得很矫情，一百多斤的成年人好像没有资格去悲春伤秋了，何况这是在不曾经历过的人看来根本无法理解的事情，那么就不再说太多了吧，其实本来我也只是想单纯的留下纪念而已。纪念2017年10月11日的久别重逢，纪念我喜欢的你们，纪念我的十年青春，纪念我的梦一场。 下面几张是五一时大学室友从上海过来杭州，一起去西湖时拍下的，感觉有几张照的还可以，也放在这里留个念想。"},{"title":"","date":"2021-07-05T07:42:09.319Z","updated":"2021-07-05T07:41:29.960Z","comments":true,"path":"cache/添加图例.html","permalink":"https://forevehg.github.io/cache/添加图例.html","excerpt":"","text":"添加新图例，引入 echarts 参考 以添加一个简单的折线图为例 在 superset-frontend/src/visualizations/ 目录下新建文件夹 SimpleLine，在 SimpleLine 文件夹下新建 images 文件夹,images 文件夹中放 SimpleLine 这个新图例的的缩略图，然后继续在 SimpleLine 文件夹下新建 SimpleLine.jsx,SimpleLinePlugin.js,transformProps.js， 新建 SimpleLinePlugin.jsimport { t } from \"@superset-ui/translation\"; import { ChartMetadata, ChartPlugin } from \"@superset-ui/chart\"; import transformProps from \"./transformProps\"; import thumbnail from \"./images/thumbnail.png\"; const metadata = new ChartMetadata({ name: t(\"Simple Line\"), description: \"\", thumbnail, }); export default class SimpleLinePlugin extends ChartPlugin { constructor() { super({ metadata, transformProps, loadChart: () => import(\"./SimpleLine.jsx\"), }); } } 新建 transformProps.js这个文件单纯的用来转换数据，可以在这里把从后端接收到的数据处理成前端展示需要的格式 export default function transformProps(chartProps) { const { height, width, datasource, formData, queryData, rawFormData, } = chartProps; const { records, columns } = queryData.data; return { width, height, data: records, columns: columns, columns_x: rawFormData.all_columns_x, columns_y: rawFormData.all_columns_y, }; } 新建 SimpleLine.jsx这部分代码我只放了个大概，主要做的工作就是通过 props 接收参数，然后导入echarts-for-react并使用，关于 echarts 的配置，直接参考 echarts 文档。 import React from \"react\"; import PropTypes from \"prop-types\"; import ReactEcharts from \"echarts-for-react\"; const propTypes = { data: PropTypes.array, columns: PropTypes.columns, width: PropTypes.number, height: PropTypes.number, columns_x: PropTypes.string, columns_y: PropTypes.string, }; //检查类型，其中data包含viz.py中返回的数据，width和height为图表宽高 class SimpleLine extends React.PureComponent { render() { const options = { xAxis: { type: \"category\", data: [], }, yAxis: { type: \"value\", }, series: [ { name: yName, data: [], type: \"line\", }, ], }; return ( &lt;ReactEcharts option={options} style={{ height: this.props.height }} >&lt;/ReactEcharts> ); } } SimpleLine.displayName = \"simple line\"; SimpleLine.propTypes = propTypes; export default SimpleLine; 修改文件/superset-frontend/src/setup/setupPlugins.ts// 文件开头导入SimpleLine import SimpleLine from '../explore/controlPanels/SimpleLine'; //注册SimpleLine,在getChartControlPanelRegistry()方法的链式调用后追加一句 .registerValue('simple_line', SimpleLine) 修改文件/superset-frontend/src/visualizations/presets/MainPreset.js//导入 import SimpleLineChartPlugin from \"../SimpleLine/SimpleLinePlugin\"; //在plugins后添加 new SimpleLineChartPlugin().configure({ key: \"simple_line\" }); 后端代码添加 class SimpleLine修改/superset/viz.py文件,在viz_types的定义前添加class SimpleLine,下面这段代码根据你需要的数据自行进行处理，这里只做最简单的演示 class SimpleLine(BaseViz): viz_type = 'simple_line' verbose_name = \"simple line\" sort_series = False is_timeseries = False def query_obj(self): d = super().query_obj() fd = self.form_data #form_data中包含界面左侧组件内容 columns = [] if not fd.get('all_columns'): #这个字段对应×××组件，不为空 raise Exception('Choose Columns') if fd.get('all_columns'): d['columns'] = columns # all_columns是左侧组件名，后面会提到 return d def get_data(self, df): # df是pandas的DataFrame类型 data = np.array(df).tolist() #假设数据很简单，不需要做别的处理 # 如果除了绘图用的数据还有别的信息，可以构造一个字典来返回 # data = {'plot_data':plot_data,'other_info':other_info} return self.handle_js_int_overflow( dict(records=df.to_dict(orient=\"records\"), columns=list(df.columns)) )"},{"title":"第一次自己住的心情","date":"2018-03-18T13:21:17.000Z","updated":"2025-03-17T06:20:47.680Z","comments":true,"path":"cache/第一次自己住的心情.html","permalink":"https://forevehg.github.io/cache/第一次自己住的心情.html","excerpt":"从高中开始住校，一直是一群人热热闹闹的生活，实习时候虽然住的群租的床位房，但最起码是有人的，陌生人也没关系，毕业后到杭州来，跟朋友合租，一直也是热热闹闹，现在是真正的开始自己一个人的租房生活了。","text":"从高中开始住校，一直是一群人热热闹闹的生活，实习时候虽然住的群租的床位房，但最起码是有人的，陌生人也没关系，毕业后到杭州来，跟朋友合租，一直也是热热闹闹，现在是真正的开始自己一个人的租房生活了。收拾好房间后觉得世界都安静下来了，自己说要出来住的勇气好像都卸掉不少，心里也慌张起来。第一天晚上，旁边住着一个女生和她的狗，本来怕狗晚上会叫，吵到人休息，但那天凌晨之后那个女生才到家，到家就开始训她的狗，全程没听到狗狗叫一声，只有链子的响动和这个女生和狗说话的声音，一直吵闹到凌晨两三点。我才发现隔断房有多不好，其实不怪隔壁女生声音大， 她是压低声音说话的，但隔断墙的板子太薄了，我用手推一下墙都会晃动，第一天晚上我就失眠了。第二天我见到了另一个隔壁住着的女生，我还不知道这层楼的wifi密码，看到这边灯光亮着就想敲门问问她，她打开门之后特别热情，真的是那种突然见到亲人的感觉，我有点儿被吓到，她极力邀请我进门坐坐，还拿出了一堆零食，我不好意思的走到她房间来，她说明天她就要走了，才在这里住了两天而已，我很惊讶，问她为什么，她说她男朋友让她去他那边，不让她在杭州呆了，还跟我讲了很多她和男朋友的故事，是个很可爱的女生，可惜那天晚上过后，我就再也没见过她了。一周后我搬到了这个女生的房间，四面都是实墙，晚上能睡好了，对面住进来一个小哥哥，长的很好看，我以为是弟弟，后来认识了之后才发现竟然是91年的，那长的也太显嫩了吧，我说要给他介绍个女朋友他整个脸都红了，是不是吓到他了哈哈哈。其他就没有什么了，继续我朝九晚六的生活，也渐渐开始喜欢一个人的生活，晚上回来看看书，想睡了就早早的睡下，不被打扰也不打扰别人，生活纯粹了很多。"},{"title":"","date":"2025-03-17T06:11:02.409Z","updated":"2025-03-17T06:11:02.409Z","comments":true,"path":"about/index.html","permalink":"https://forevehg.github.io/about/index.html","excerpt":"","text":"个人信息 孙佳丽 / 女 / 1994 电话/微信：18506576297 / sunjl97 Email：1217304483@qq.com 教育经历：本科 / 河南科技学院-计算机科学与技术(2013 年~2017 年) 工作年限：7 年 期望职位：Web 前端开发 期望城市：杭州 技术博客：http://sunjl729.cn Github：https://github.com/forevehg 技能清单熟练的技能 Web 开发：Html / Css / Javascript 前端框架：Vue2 / Vue3 小程序：微信小程序原生 / uni-app 前端UI库：Element / iView / Ant-Design / Vant 前端工程化：Webpack / Vite / TypeScript / Sass / Less / Stylus / Tailwind 版本管理：Git 其他：Echarts / Photoshop 了解的技能 React / React Native / Electron / Node / Express / Koa2 / Nuxt / QianKun / Superset / JinJia2 / D3.js 工作经历杭州微医集团有限公司（2021 年 8 月 ~ 2025 年 3 月）慢病一体化管理平台 项目背景：该项目以区域内居民健康档案为基础，实现慢病的全流程管理，包括居民慢病筛查，慢病签约、慢病全周期管理等内容 工作内容： 负责慢病管理健管师PC端、患者小程序端、公众号H5页面的开发 使用 Vue3，Vite，Vue-Router，Element-Plus，Echarts，Vant，uni-app，等技术 设计和实现基于RBAC模型的通用权限管理系统，标准化权限管理 实现通过配置生成各类慢病档案和慢病随访表单，提高开发效率 齐鲁保 项目背景：该项目是济南城市定制的商业医疗保险产品，已成功运营和维护三年 工作内容： 负责投保H5页面、商保搭建平台、保司后台等系统开发和维护 使用集团SSR脚手架搭建保险C端项目，使用Vue2，Vuex，Vue-Router，Vant等技术 实现通过页面配置组件直接生成投保H5页面、预览投保页，减少开发工作量 封装和维护搭建商业保险页面所需的公共基础组件和业务组件 云HIS系统 项目背景：该项目是一套标准化的医疗信息管理系统，涵盖了体检、门诊、住院、药房药库等医疗机构的业务全流程，上线后累计接入20+医疗机构 工作内容： 负责云HIS挂号登记、医生接诊、开方、收费、发药等功能模块 使用 Vue2，Vuex，Vue-Router，Element-UI， QianKun等技术 封装医保接入流程，成功接入多个省市的医保 杭州浮云网络科技（2020 年 6 月 ~ 2021 年 8 月）斗地主牌库系统 项目背景: 该项目为斗地主业务提供牌库支持 工作内容: 独立负责前端开发 使用 Umi 搭建项目，使用React，TypeScript，Ant-Design 等技术 实现通过页面配置生成斗地主牌方案 封装web端斗地主的对局流程，实现牌局回放、牌局标注、残局试打等功能 伏羲平台-独立开发 项目背景: 该项目是一个BI可视化平台 工作内容: 基于superset开源项目进行二次开发 使用 React，Echarts，D3JS，JinJia2 等技术 实现模板⻚面修改，可视化图表开发，新增图例，开发定制化大屏 阅读superset的源码，了解大型开源项目的架构，对日后的工作很有帮助 杭州通明文化传媒有限公司（2017 年 6 月 ~ 2020 年 6 月）舆情监测平台/舆情助手小程序 项目背景: 该项目的中后台系统用于收集和监测网络舆情信息，支持将近 20 个主流社交平台，每个平台提供特定的舆情分析，正负面判断，舆情维护，统计等功能；小程序的主要功能为收集用户的舆情监测计划、生成舆情报告、推送重点舆情等 工作内容: 负责舆情监测、舆情维护、项目统计模块开发，独立负责舆情助手小程序开发 使用 Vue，Vuex，Vue-Router，Element-UI，Echarts，微信小程序原生等技术 封装小程序导航栏，日期选择，Tab切换等公共组件 按舆情平台将业务操作和展示差异封装为策略类，提高了新增或者下架平台时的开发效率 开源项目和作品开源项目 小食堂：使用 React Native + Mobx 实现的美食资讯类 APP vue-live2d-model：实现在 vue 中添加 live2d wechat-applet-word-cloud：在原生微信小程序中使用 wordcloud2.js 以及一些 demo 技术文章 vue-loader都做了些什么 写一个 Promise 弹性盒模型之 flex 属性 致谢最后要感谢您花时间阅读我的简历，期待能有机会和您共事。 body { line-height: 1.75; color: #323232; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; /* background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%); */ background-size: 20px 20px; background-position: center center; } hr { height: 1px; padding: 0; border: none; border-top: 1px solid rgba(239, 112, 96, 0.5); } h2 { color: #323232; margin: 1em auto; border-bottom: 2px solid rgb(239, 112, 96); } .header { display: inline-block; border-bottom: 2px solid rgb(239, 112, 96); } .project-name { font-weight: 500; padding-left: 10px; border-left: 3px solid rgb(239, 112, 96); } .highlight { font-weight: 500; font-size: 15px; color: rgb(239, 112, 96); a { color: rgb(239, 112, 96); } } ul { padding-inline-start: 30px; } .span_100 { /* color: blue; */ display: inline-block; width: 100px; }"},{"title":"contact","date":"2020-05-16T09:25:30.000Z","updated":"2020-05-17T14:29:48.000Z","comments":true,"path":"concat/index.html","permalink":"https://forevehg.github.io/concat/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-12-30T09:10:59.000Z","updated":"2020-05-17T13:56:06.000Z","comments":true,"path":"categories/index.html","permalink":"https://forevehg.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-06-28T02:25:16.576Z","updated":"2021-06-28T02:24:43.967Z","comments":true,"path":"about/index.html","permalink":"https://forevehg.github.io/about/index.html","excerpt":"","text":"&#x8054;&#x7CFB;&#x65B9;&#x5F0F; /* From extension zhuangtongfa.material-theme */ .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body { box-sizing: border-box; min-width: 200px; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body blockquote { background-color: initial; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body pre { color: initial; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body code { color: inherit; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body pre code { color: initial; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body code > div { background: none; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body table th, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body table td { border: 1px solid rgba(171, 178, 191, 0.5) !important; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body.showEditorSelection .code-active-line:before { border-left: none; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body.showEditorSelection .code-line:hover:before { border-left: none; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body.showEditorSelection .code-line .code-line:hover:before { border-left: none; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body p, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body blockquote, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ul, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ol, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body dl, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body table, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body pre { margin-top: 16px; margin-bottom: 16px; } /* Generated from 'node_modules/github-markdown-css/github-markdown.css' */ @font-face { font-family: octicons-link; src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format(\"woff\"); } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body { -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; line-height: 1.5; color: #abb2bf; font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"; font-size: 16px; line-height: 1.5; word-wrap: break-word; background: #282c34; padding-top: 20px; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-c { color: #6a737d; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-c1, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-s .pl-v { color: #005cc5; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-e, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-en { color: #6f42c1; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-smi, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-s .pl-s1 { color: #24292e; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-ent { color: #22863a; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-k { color: #d73a49; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-s, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-pds, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-s .pl-pse .pl-s1, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-sr, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-sr .pl-cce, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-sr .pl-sre, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-sr .pl-sra { color: #032f62; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-v, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-smw { color: #e36209; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-bu { color: #b31d28; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-ii { color: #fafbfc; background-color: #b31d28; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-c2 { color: #fafbfc; background-color: #d73a49; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-c2::before { content: \"^M\"; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-sr .pl-cce { font-weight: bold; color: #22863a; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-ml { color: #735c0f; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-mh, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-mh .pl-en, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-ms { font-weight: bold; color: #005cc5; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-mi { font-style: italic; color: #24292e; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-mb { font-weight: bold; color: #24292e; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-md { color: #b31d28; background-color: #ffeef0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-mi1 { color: #22863a; background-color: #f0fff4; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-mc { color: #e36209; background-color: #ffebda; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-mi2 { color: #f6f8fa; background-color: #005cc5; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-mdr { font-weight: bold; color: #6f42c1; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-ba { color: #586069; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-sg { color: #959da5; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-corl { text-decoration: underline; color: #032f62; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .octicon { display: inline-block; vertical-align: text-top; fill: currentColor; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body a { background-color: transparent; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body a:active, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body a:hover { outline-width: 0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body strong { font-weight: inherit; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body strong { font-weight: bolder; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h1 { font-size: 2em; margin: 0.67em 0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body img { border-style: none; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body code, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body kbd, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body pre { font-family: monospace, monospace; font-size: 1em; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body hr { box-sizing: content-box; height: 0; overflow: visible; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body input { font: inherit; margin: 0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body input { overflow: visible; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body [type=checkbox] { box-sizing: border-box; padding: 0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body * { box-sizing: border-box; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body input { font-family: inherit; font-size: inherit; line-height: inherit; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body a { color: #528bff; text-decoration: none; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body a:hover { text-decoration: underline; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body strong { font-weight: 600; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body hr { height: 0; margin: 15px 0; overflow: hidden; background: transparent; border: 0; border-bottom: 1px solid #dfe2e5; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body hr::before { display: table; content: \"\"; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body hr::after { display: table; clear: both; content: \"\"; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body table { border-spacing: 0; border-collapse: collapse; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body td, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body th { padding: 0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h1, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h2, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h3, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h4, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h5, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h6 { margin-top: 0; margin-bottom: 0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h1 { font-size: 32px; font-weight: 600; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h2 { font-size: 24px; font-weight: 600; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h3 { font-size: 20px; font-weight: 600; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h4 { font-size: 16px; font-weight: 600; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h5 { font-size: 14px; font-weight: 600; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h6 { font-size: 12px; font-weight: 600; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body p { margin-top: 0; margin-bottom: 10px; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body blockquote { margin: 0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ul, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ol { padding-left: 0; margin-top: 0; margin-bottom: 0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ol ol, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ul ol { list-style-type: lower-roman; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ul ul ol, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ul ol ol, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ol ul ol, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ol ol ol { list-style-type: lower-alpha; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body dd { margin-left: 0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body code { font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace; font-size: 12px; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body pre { margin-top: 0; margin-bottom: 0; font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace; font-size: 12px; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .octicon { vertical-align: text-bottom; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-0 { padding-left: 0 !important; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-1 { padding-left: 4px !important; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-2 { padding-left: 8px !important; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-3 { padding-left: 16px !important; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-4 { padding-left: 24px !important; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-5 { padding-left: 32px !important; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .pl-6 { padding-left: 40px !important; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body::before { display: table; content: \"\"; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body::after { display: table; clear: both; content: \"\"; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body > *:first-child { margin-top: 0 !important; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body > *:last-child { margin-bottom: 0 !important; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body a:not([href]) { color: inherit; text-decoration: none; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .anchor { float: left; padding-right: 4px; margin-left: -20px; line-height: 1; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .anchor:focus { outline: none; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body p, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body blockquote, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ul, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ol, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body dl, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body table, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body pre { margin-top: 0; margin-bottom: 16px; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body hr { height: 0.25em; padding: 0; margin: 24px 0; background-color: #e1e4e8; border: 0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body blockquote { /* padding: 0 1em; color: #6a737d; border-left: 0.25em solid #dfe2e5; */ padding: 8.5px 17px; margin: 1.5em 0; font-size: inherit; color: #7c879c; border-color: #4b5362; border-width: 4px; border-left: 5px solid #4b5362; background: transparent; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body blockquote > :first-child { margin-top: 0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body blockquote > :last-child { margin-bottom: 0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body kbd { display: inline-block; padding: 3px 5px; font-size: 11px; line-height: 10px; color: #444d56; vertical-align: middle; background-color: #fafbfc; border: solid 1px #c6cbd1; border-bottom-color: #959da5; border-radius: 3px; box-shadow: inset 0 -1px 0 #959da5; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h1, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h2, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h3, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h4, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h5, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h6 { margin-top: 24px; margin-bottom: 16px; font-weight: 600; line-height: 1.25; color: #f0f0f0; border-bottom: none; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h1 .octicon-link, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h2 .octicon-link, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h3 .octicon-link, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h4 .octicon-link, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h5 .octicon-link, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h6 .octicon-link { color: #1b1f23; vertical-align: middle; visibility: hidden; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h1:hover .anchor, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h2:hover .anchor, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h3:hover .anchor, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h4:hover .anchor, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h5:hover .anchor, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h6:hover .anchor { text-decoration: none; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h1:hover .anchor .octicon-link, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h2:hover .anchor .octicon-link, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h3:hover .anchor .octicon-link, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h4:hover .anchor .octicon-link, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h5:hover .anchor .octicon-link, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h6:hover .anchor .octicon-link { visibility: visible; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h1 { padding-bottom: 0.3em; font-size: 2em; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h2 { padding-bottom: 0.3em; font-size: 1.5em; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h3 { font-size: 1.25em; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h4 { font-size: 1em; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h5 { font-size: 0.875em; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body h6 { font-size: 0.85em; color: #6a737d; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ul, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ol { padding-left: 2em; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ul ul, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ul ol, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ol ol, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body ol ul { margin-top: 0; margin-bottom: 0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body li { word-wrap: break-all; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body li > p { margin-top: 16px; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body li + li { margin-top: 0.25em; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body dl { padding: 0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body dl dt { padding: 0; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: 600; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body dl dd { padding: 0 16px; margin-bottom: 16px; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body table { display: block; width: 100%; overflow: auto; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body table th { font-weight: 700; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body table th, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body table td { padding: 6px 13px; /* border: 1px solid #dfe2e5; */ } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body table tr { /* background-color: #fff; */ /* border-top: 1px solid #c6cbd1; */ } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body table tr:nth-child(2n) { /* background-color: #f6f8fa; */ } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body img { max-width: 100%; box-sizing: content-box; display: inline-block; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body img[align=right] { padding-left: 20px; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body img[align=left] { padding-right: 20px; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body code { padding: 0.2em 0.4em; margin: 0; font-size: 85%; background-color: #3a3f4b; border-radius: 3px; color: white; margin: 0 1px; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body pre { word-wrap: normal; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body pre > code { padding: 0; margin: 0; font-size: 100%; word-break: normal; white-space: pre; background: transparent; border: 0; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .highlight { margin-bottom: 16px; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .highlight pre { margin-bottom: 0; word-break: normal; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .highlight pre, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; /* background-color: #f6f8fa; */ border-radius: 3px; background-color: #31363f; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body pre code { display: inline; max-width: auto; padding: 0; margin: 0; overflow: visible; line-height: inherit; word-wrap: normal; background-color: transparent; border: 0; color: #abb2bf; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .full-commit .btn-outline:not(:disabled):hover { color: #005cc5; border-color: #005cc5; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body kbd { display: inline-block; padding: 3px 5px; font: 11px \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace; line-height: 10px; color: #444d56; vertical-align: middle; background-color: #fafbfc; border: solid 1px #d1d5da; border-bottom-color: #c6cbd1; border-radius: 3px; box-shadow: inset 0 -1px 0 #c6cbd1; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body :checked + .radio-label { position: relative; z-index: 1; border-color: #0366d6; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .task-list-item { list-style-type: none; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .task-list-item + .task-list-item { margin-top: 3px; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body .task-list-item input { margin: 0 0.2em 0.25em -1.6em; vertical-align: middle; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"].vscode-body hr { border-bottom-color: #eee; } /* Atom One Dark by Daniel Gamage Original One Dark Syntax theme from https://github.com/atom/one-dark-syntax base: #282c34 mono-1: #abb2bf mono-2: #818896 mono-3: #5c6370 hue-1: #56b6c2 hue-2: #61aeee hue-3: #c678dd hue-4: #98c379 hue-5: #e06c75 hue-5-2: #be5046 hue-6: #d19a66 hue-6-2: #e6c07b */ .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs { display: block; overflow-x: auto; padding: 0.5em; color: #abb2bf; background: #282c34; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-comment, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-quote { color: #5c6370; font-style: italic; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-doctag, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-keyword, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-formula { color: #c678dd; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-section, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-name, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-selector-tag, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-deletion, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-subst { color: #e06c75; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-literal { color: #56b6c2; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-string, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-regexp, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-addition, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-attribute, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-meta-string { color: #98c379; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-built_in, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-class .hljs-title { color: #e6c07b; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-attr, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-variable, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-template-variable, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-type, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-selector-class, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-selector-attr, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-selector-pseudo, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-number { color: #d19a66; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-symbol, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-bullet, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-link, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-meta, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-selector-id, .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-title { color: #61aeee; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-emphasis { font-style: italic; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-strong { font-weight: bold; } .vscode-dark[data-vscode-theme-name=\"One Dark Pro\"] .hljs-link { text-decoration: underline; } body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif; font-size: 14px; line-height: 1.6; } .task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; } title: about date: 2021-06-22 20:47:56 联系方式 手机：18506576297 Email：1217304483@qq.com 个人信息 孙佳丽/女/1994 学历：本科 教育经历：河南科技学院-计算机科学与技术(2013 年~2017 年) 工作年限：4 年 技术博客：http://sunjl729.cn/ Github：https://github.com/ForeveHG 期望职位：Web 前端开发 期望薪资：面议 期望城市：杭州/上海(目前在杭州，可去上海) 技能清单 熟练使用的技能 Web 开发：Html/Css/Javascript/TypeScript 前端框架：Vue/React 前端 UI 组件库：Element-UI/iView/Ant-Design/Vant/Bootstrap 前端工具：Webpack/Sass/Less/Stylus 脚手架：Vue-Cli/UmiJS 版本管理：Git 其他：微信小程序原生，Echarts，Photoshop 了解的技能 React Native/Mobx/Electronic/Node/Express/Koa2/NextJS/D3.js/jinjia2/superset 工作经历 杭州浮云网络科技-大数据开发部 职位名称：前端开发工程师 在职时间： 2020 年 6 月 ~ 2021 年 7 月 主要工作： 参与项目评审，配合产品、UI 和后端人员，进行项目的开发和测试，最终部署上线 负责大数据部门的前端工作，包括后台系统、superset 二次开发、数据大屏、h5 活动页面等 杭州通明文化传媒有限公司-技术部 职位名称： 前端开发工程师 在职时间： 2017 年 6 月 ~ 2020 年 6 月 主要工作： 参与项目评审，配合产品、UI 和后端人员，进行项目的开发和测试，最终部署上线 负责舆情监测产品线的前端工作，包括后台系统、微信小程序以及一些 h5 活动页面等 项目经历 (浮云)斗地主牌库系统-独立开发 项目背景：该项目的是一个后台系统，为斗地主业务提供牌库支持 工作内容：我负责该项目全部的前端开发工作，实现的主要功能：通过页面配置生成斗地主牌方案、为游戏房间指定牌方案、牌局试打、用户牌局回放、牌局标注、残局试打、伙牌剔除等，在技术上使用 Umi 搭建项目，React+TypeScript+Ant-Design 完成开发，项目主要难点首先是配置牌方案的表单非常复杂，在开发过程中也对react组件封装、antd表单使用都有了更深入的了解，其次是在系统内实现了简易斗地主，封装了对局流程，后续增加其他对局需求时，只用修改少量代码，节省了开发时间，方便后续维护。 (浮云)伏羲平台-独立开发 项目背景：该项目是一个数据查询和可视化平台，基于superset开源项目进行二次开发 工作内容：我在此项目主要负责模板页面修改，可视化图表开发，新增图例，开发定制化大屏等，技术上用到 React，Echarts，D3JS，JinJia2等，这个项目中，superset自身是一个很优秀的开源项目，但要进行深度二次开发的话发现网络上资料比较少，大部分靠自己摸索，并且在之前没接触过python的模板语言，通过这个项目，阅读了superset的源码，了解了一个大型开源项目的架构，对日后的工作很有帮助。 (通明)舆情监测平台-主开发 项目背景：该项目用于监测网络舆情信息，支持将近 20 个主流社交平台，每个平台提供特定的舆情分析，正负面判断，舆情维护，统计等功能 工作内容：我在此项目主要负责舆情监测、舆情维护、项目统计模块，使用 Vue，Vuex，Vue-Router，Element-UI，Echarts 等技术实现，在这个项目中，平台的展示页面或业务功能都大同小异，包括之后如果新增或删除社交平台，还要添加相应的页面和一套功能，了解需求后采用 JS 策略模式，将业务操作和展示差异按平台封装成策略类，这样以后新增或者删除平台也变得非常容易，项目上线后，后期的维护和新需求的处理都变得非常快速，获得了业务部门的好评。 (通明)舆情助手小程序-独立开发 项目背景：该项目主要为客户提供热搜通知，历史热搜查询，分钟级热搜数据导出以及舆论方向统计等功能 工作内容：该项目由我独立开发和维护，使用微信小程序原生开发，图表展示使用了 f2Chart，词云图使用 wordcloud2.js 封装了微信小程序内可用的词云组件，根据需求和 UI 设计，封装了 Navigation 导航栏，日期选择，Tab 切换等组件，由于该小程序必须获取到用户手机号以及公司职位等个人信息，涉及到引导用户关注公众号，IOS 虚拟支付等微信不允许的问题，也通过这个项目在小程序审核方面获得了一些经验。 (通明)小 V 业务管理平台-辅助开发 项目背景：该项目是一个派单系统，配合接单 APP，是支撑公司底层业务的主要项目 工作内容：我在此项目主要负责即时通讯模块，实现建群、群聊、单聊、群内派单、消息提醒等功能，在技术上我使用 Vue 搭建聊天窗口，Vuex 做状态管理，聊天功能接入了融云 im，这个项目中，最大的难点是如何在浏览器中存储聊天记录和会话信息，对比了目前浏览器本地存储的方式后我选择了 indexDB，可以在本地存储大量的数据，封装了增删改查的接口，配合云端记录，很好的实现了对聊天记录的存储、访问和清理。 (通明)数据中心(ERP)-主开发 项目背景：该项目是公司的 OA 系统和 ERP 系统的结合 工作内容：我在此项目主要负责组织架构，绩效考核，周报，媒介资源库等功能，使用 Vue，Vuex，Vue-Router，iView 等技术实现，在该项目中，绩效考核模块主要是操作表格，当时 iView 中的表格组件满足不了很多需求，所以我二次开发了 iView 的表格组件，实现了单元格的合并行，合并列，以及单元格中添加各种组件等项目中常用的操作；另外比较困难的是对考核状态的管理，每个考核阶段表格以及表格中的组件呈现的样式也不一样，最后采用的 js 状态管理模式，避免了代码中大量的判断，对于考核步骤的添加或者修改都更加简单，方便后期的项目维护。 其他项目 浮云决策平台、势茂数智平台、势茂数智平台移动端、小 V 平台移动端，小 V 平台小程序版，爬虫预警系统，营销助手小程序以及一些节日活动所需的 h5 页面等。 开源项目和作品 开源项目 小食堂：使用 React Native + Mobx 实现的美食资讯类 APP vue-live2d-model：实现在 vue 中添加 live2d wechat-applet-word-cloud：在原生微信小程序中使用 wordcloud2.js 以及一些 demo 技术文章 vue-loader都做了些什么 写一个 Promise 弹性盒模型之 flex 属性 致谢 最后要感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"Tags","date":"2016-12-30T09:14:17.000Z","updated":"2020-05-17T13:56:06.000Z","comments":true,"path":"tags/index.html","permalink":"https://forevehg.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Performance的使用","slug":"Performance的使用","date":"2023-05-17T00:38:42.000Z","updated":"2025-03-17T05:59:30.916Z","comments":true,"path":"2023/05/17/Performance的使用/","link":"","permalink":"https://forevehg.github.io/2023/05/17/Performance的使用/","excerpt":"Performance的使用浏览器多进程架构 进程 负责的工作 包含的线程 浏览器进程 负责浏览器的导航栏、书签、前进、后退按钮等，还会控制我们看不见的部分，包括文件的读写等 UI线程等 渲染进程 渲染进程负责网页展示相关的所有工作，主要任务是将HTML，CSS，以及JavaScript转变为我们可以进程交互的网页内容。每一个tab页、页面内的每一个iframe都会分配一个单独的渲染进程 主线程:渲染主线程的任务执行过程; Compositor: 合成线程，将绘制列表合成页面;Chrome_ChildIOThread线程: IO线程；Raster: 光栅化线程池等 GPU进程 负责独立于其他进程的GPU任务，处理来自不同tab的渲染请求，并把他们在界面上画出来 网络进程 负责页面的网络资源加载 Plugin进程 负责网页使用的所有插件","text":"Performance的使用浏览器多进程架构 进程 负责的工作 包含的线程 浏览器进程 负责浏览器的导航栏、书签、前进、后退按钮等，还会控制我们看不见的部分，包括文件的读写等 UI线程等 渲染进程 渲染进程负责网页展示相关的所有工作，主要任务是将HTML，CSS，以及JavaScript转变为我们可以进程交互的网页内容。每一个tab页、页面内的每一个iframe都会分配一个单独的渲染进程 主线程:渲染主线程的任务执行过程; Compositor: 合成线程，将绘制列表合成页面;Chrome_ChildIOThread线程: IO线程；Raster: 光栅化线程池等 GPU进程 负责独立于其他进程的GPU任务，处理来自不同tab的渲染请求，并把他们在界面上画出来 网络进程 负责页面的网络资源加载 Plugin进程 负责网页使用的所有插件 多进程架构的优点 容错性：每个tab都有独立的渲染进程，当一个tab也崩溃时，关闭这个tab，不影响其他tab页 安全性和沙盒性：操作系统提供方法限制每个进程拥有的能力，所以浏览器可以让某些进程不具备某些特定的功能，比如tab渲染进程会处理来自用户的输入，所以chrome限制了他们对系统文件随机读写的能力 多进程架构的缺点 内存消耗：每个进程都有独立的内存空间，不像一个进程中的所有线程可以公用内存空间，这会造成一些基础架构会在不同进程的内存空间同时存在(比如V8 JavaScript引擎)，这些重复内容会消耗更多的内存。为了节省内存，chrome会限制启动的进程数目，当进程数达到一定的界限后，chrome会将访问同一个站点的tab都放在一个进程里面跑 同一站点的定义为：根域名+协议 性能指标简介Performance面板中的各项指标就记录了浏览器多个进程之间配合完成页面渲染的流程，先简单介绍一下各个指标的基本内容。 Network指标Network指标主要是记录页面中每个网络请求在网络进程中所消耗的时长 HTML: 蓝色 CSS: 紫色 JS: 黄色 Images: 绿色 上图每个请求的柱状图对应Network的Timing面板： 左侧的灰线表示请求排队时间(Queueing)和发起连接(Connection Start)这一组操作共花费的时间。 排队时间(Queueing)请求正在排队指的是： 请求被渲染引擎推迟，因为该请求的优先级低于其他关键资源的优先级 请求被暂停，等待将要释放的TCP套接字 请求被暂停，因为有“队头阻塞”, 浏览器仅允许每个域名同时最多发起6个请求(http1.0/http1.1) 生成磁盘缓存条目所用的时间 发起连接(Connection Start)包括阻塞时间(Stalled)、DNS Lookup、建立TCP连接(TCP握手、协商SSL)等； 浅色代表发送请求(Request sent)和等待首字节响应(TTFB)的时间，这部分包括服务器处理的时间，网络延迟时间等； 深色代表下载内容，即从接收到第一个字节到最后一个字节接收完毕花费的时间； 右侧的灰线表示等待渲染主线程响应的时间； Timings指标记录关键的时间节点产生的数据信息，FP，FCP，LCP等 指标 触发事件 触发时间 DCL DOMContentLoaded 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架的完全加载。 L load 当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件 FP First Paint 首次绘制（First Paint）渲染进程确认要渲染当前的请求后，渲染进程会创建一个空白页面，我们把创建空白页面的这个时间点称为FP FCP First Contentful Paint 首次有内容的绘制，第一个dom元素绘制完成的时间点 LCP Largest Contentful Paint 最大内容绘制,报告从首次开始加载的时间开始，到可视区域内可见的最大图像或文本块完成渲染的相对时间，最大元素完成渲染的时间点 Frame指标记录浏览器生成每帧的记录 鼠标移到某个帧上，会展示渲染当前帧花费的时间和fps(帧每秒) 60fps就是60帧每秒，屏幕每秒会展示60帧静态图像，1000ms / 60 ≈ 16.7ms，所以只有在16.7毫秒内完成一次帧绘制，页面看起来才会更流畅，一帧绘制的时间超过16.7ms，就会出现掉帧的情况，页面会表现出卡顿的现象 Layout Shift由Layout Instability API定义，每当视口中两次渲染帧之间的可视元素改变了其起始位置时都会触发layout-shift entries，改变了起始位置的元素被认为是不稳定元素。由于LS只会发生在改变了初始位置的已有元素上，只要新加入的元素并不会造成其他可见元素改变位置，它将不会被当成是LS元素。 Main指标记录渲染进程中主线程的执行记录，渲染进程负责标签（tab）内发生的所有事情，在渲染进程里面，主线程（main thread）处理了绝大多数你发送给用户的代码。 Event: beforeunload当浏览器窗口关闭或者刷新时，会触发beforeunload事件。当前页面不会直接关闭，可以点击确定按钮关闭或刷新，也可以取消关闭或刷新。如果实现了beforeunload事件，就会在这一阶段被触发。 Event: pagehide当浏览器在显示与会话历史记录不同的页面的过程中隐藏当前页面时, pagehide(页面隐藏)事件会被发送到一个Window 。例如，当用户单击浏览器的“后退”按钮时，当前页面在显示上一页之前会收到一个pagehide(页面隐藏)事件。 Event: visibilitychange当其选项卡的内容变得可见或被隐藏时，会在文档上触发 visibilitychange (能见度更改)事件 Event: webkitvisibilitychange当前网页在可见和不可见之间变换的时候调用 Event: unload当文档或一个子资源正在被卸载时, 触发 unload事件。 Send Request表示网络请求已发送 Receive Response表示已经接收到HTTP响应头 commitNavigationEnd导航结束 Receive Data接收数据，如果数据量大会存在多个Recive Data过程 Finish Loading所有数据接收完成后执行，表示网络请求已经完成 Parse HTML构建DOM树，以内渲染引擎无法直接理解html内容，需要将其解析为DOM树结构，DOM树表示了页面上所有节点的内容和节点之间的关系。 如果遇到script标签，就暂停DOM树构建，如果是内联script，直接执行代码，如果是外部js文件，在过去会触发Send Request事件，网络进程开始请求外部js文件，请求完成后触发Finish Loading事件, 之后触发Evaluate Script事件，开始执行js代码，执行完成后再继续执行Parse HTML构建DOM树，如果遇到如.css等子资源，还是会触发Send Request事件，网络进程请求资源，但是不会阻塞DOM树的构建。 现在chrome已做预解析优化，在渲染主线程接收到HTML的字节流后，会开启预解析线程，分析HTML中包含的JS、CSS等资源，解析到这些资源链接后，预解析线程会让网络进程提前下载这些文件， 资源接收的流程： Send Request Receive Response Receive Data Receive Data …. Receive Data Parse Stylesheet/Parse HTML Receive Data …. Finish Loading js文件是先Finish Loading后再Evaluate Script。 js下载：js下载会阻塞其他资源的下载，chrome做了预加载优化，会提前下载资源 js执行：script标签会中断DOM树构建 Parse Stylesheet构建CSSOM，跟html一样，渲染引擎也无法直接理解css内容，所以需要将 CSS 文本转换为渲染引擎可以理解的结构CSSOM，转换为CSSOM之后，js可以直接操作样式，也为下一步合成布局树提供样式信息。可以在控制台通过styleSheets查看： Evaluate Script执行js代码 Recalculate Style计算 DOM 树中每个节点的样式，涉及css继承规则和层叠规则，这个阶段最终输出的内容是每个 DOM 节点的样式，可以在devtools的 ComputedStyle 内查看 Layout生成可见节点的布局树，这个布局树中只包含DOM树中的可见节点，并计算出每个DOM 元素的几何位置信息。 Update Layer Tree构建渲染图层树，什么情况下会为节点创建新图层： 页面的根元素 拥有层叠上下文属性的元素会被提升为单独的一层。 明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。 需要剪裁（clip）的地方也会被创建为图层 剪裁区域占一层，内容占一层，如果有滚动条，滚动单独占一层 &lt;body> &lt;p style=\"position:fixed;\">&lt;/span>hello, &lt;span>web performance&lt;/span> students&lt;/p> &lt;div style=\"height: 100px;overflow: scroll;\"> &lt;img src=\"https://cdn.ne-smalltown.com/453.jpg--ljg4NsMmh4S3skxKXaOaZsdjXjn0?imageView2/2/w/327/h/312/interlace/1\"/> &lt;/div> &lt;/body> Paint生成绘制列表，绘制列表用来记录绘制顺序和绘制指令，从下图可以看到图层p的绘制列表： Composite Layers将绘制列表提交给渲染进程中的合成线程 Compositor指标记录渲染进程中合成线程的执行记录，合成线程主要负责将图层划分为图块，然后会向光栅化线程发送指令，由光栅化线程池来生成位图 Raster指标记录渲染进程光栅化线程池中每个光栅化线程的执行记录，光栅化负责将图块转为位图，最小的执行单位是图块，光栅化线程回和GPU进程通信，利用GPU进程来实现快速栅格化。 GPU指标执行raster指标中的快速光栅化任务生成位图，并保存在GPU内存中 Chrome_ChildIOThread指标记录用户输入事件、网络事件、设备相关等事件 Interactions指标记录用户的交互操作 一些例子在Performance面板看css加载阻塞script会阻塞DOM树构建，那css会阻塞DOM树构建吗？因为js可以更改DOM，所以js代码一定会阻塞DOM树构建： 内部script代码: Parse HTML时遇到内部script代码时，会暂停DOM树构建，先执行js代码，执行完成之后再继续进行DOM树构建 外部script代码先通过网络进程下载script代码，下载后执行js代码，执行完成之后再继续进行DOM树构建 因为js也可以更改样式，所以css在某些情况下会阻塞js资源下载和执行，相当于阻塞了DOM树构建： 通过外部引入css资源，后面跟有嵌入js代码时：等待css资源下载和Parse Stylesheet，然后才能执行嵌入的js代码 通过外部引入css资源，后面根据有js外部引入资源时：因为css不会阻塞DOM树构建，所以会同时发起css和js资源请求，但无论请求完成的快慢，js资源请求都需要等待css资源下载并且在主线程完成Parse Stylesheet后，再执行js代码 帧优化https://googlechrome.github.io/devtools-samples/jank/ 层爆炸长任务优化因为页面渲染和 JS的 执行都在主线程中执行，会相互阻塞，如果 JS 有长时间(超过50ms)执行的 Task，就会长期占据主线程，阻塞渲染，导致页面卡顿。可以通过Performance面板找出长任务，优化长任务。 有两种常见的造成长任务的方式： 一段同步代码被递归调用或者处理一段复杂的逻辑导致耗时较长 long task: let total = 100; function a() { let s = 0; for (let i = 0; i &lt; total; i++) { let div = document.createElement('div'); let span = document.createElement('span') div.innerHTML = `hello`; span.innerHTML = i div.appendChild(span) document.body.appendChild(div); } } a(); 优化: let current = 0; let total = 100; let count = 10; function a() { let s = 0; for (let i = 0; i &lt; count; i++) { let div = document.createElement('div'); let span = document.createElement('span') div.innerHTML = `hello`; span.innerHTML = current++ div.appendChild(span) document.body.appendChild(div); } } for(let j = 0; j &lt; total; j+=count) { setTimeout(a); } 一个Promise具有多个.then处理程序，由于Promise的then处理程序是在MicroTask队列中排队，并且将MicroTask队列中的任务连续执行，直到队列为空，它可能会导致当前任务执行超过50ms: long task: let current = 0; let count = 10; function a() { let s = 0; for (let i = 0; i &lt; count; i++) { let div = document.createElement('div'); let span = document.createElement('span'); div.innerHTML = `hello`; span.innerHTML = current++; div.appendChild(span); document.body.appendChild(div); } } Promise.resolve() .then(a) .then(a) .then(a) .then(a) .then(a) .then(a) .then(a) .then(a) .then(a) .then(a); 优化： function a() { let s = 0; for (let i = 0; i &lt; count; i++) { let div = document.createElement('div'); let span = document.createElement('span'); div.innerHTML = `hello`; span.innerHTML = current++; div.appendChild(span); document.body.appendChild(div); } } function b() { setTimeout(a, 0) } Promise.resolve() .then(b) .then(b) .then(b) .then(b) .then(b) .then(b) .then(b) .then(b) .then(b) .then(b); 使用webworker进行优化 参考示例： https://googlechrome.github.io/devtools-samples/jank/ 示例2： https://www.ne-smalltown.com/ https://docs.google.com/document/d/1bCDuq9H1ih9iNjgzyAL0gpwNFiEP4TZS-YLRp_RuMlc/edit# https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=en https://developer.chrome.com/docs/devtools/evaluate-performance/performance-reference/ https://time.geekbang.org/column/article/118826 https://w3c.github.io/longtasks/ https://web.dev/rail/#response:-process-events-in-under-50ms https://javascript.plainenglish.io/how-to-optimize-long-tasks-blocking-javascript-in-browsers-d49508f72c9 父元素设置了filter，子元素设置定位属性，将根据父元素来定位 .container { display: inline-block; width: 200px; height: 200vh; border: 1px solid; } .container>div { position: fixed; width: 100px; height: 100px; background: red; color: #fff; } &lt;div class=\"container\"> &lt;div>I am fixed on scroll&lt;/div> &lt;/div> &lt;div class=\"container\" style=\"filter:grayscale(1);\"> &lt;div>I move with the scroll&lt;/div> &lt;/div> 下面属性都应用： filter transform ref backdrop-filter ref perspective ref contain ref transform-style ref content-visibility ref will-change when used with one of the above values","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://forevehg.github.io/tags/浏览器/"},{"name":"Chrome","slug":"Chrome","permalink":"https://forevehg.github.io/tags/Chrome/"}],"keywords":[]},{"title":"浏览器渲染流程","slug":"浏览器合成层","date":"2023-04-07T13:09:14.000Z","updated":"2025-03-17T07:06:33.667Z","comments":true,"path":"2023/04/07/浏览器合成层/","link":"","permalink":"https://forevehg.github.io/2023/04/07/浏览器合成层/","excerpt":"浏览器渲染流程 构建DOM树(Parse HTML)：浏览器无法直接理解和使用HTML，需要通过html解析器，处理HTML标记并构造DOM树，可以通过document节点查看","text":"浏览器渲染流程 构建DOM树(Parse HTML)：浏览器无法直接理解和使用HTML，需要通过html解析器，处理HTML标记并构造DOM树，可以通过document节点查看 构建CSSOM树(Parse Stylesheet)：和HTML一样，浏览器需要将CSS转换成可以使用的CSSOM，CSS对象模型是一组允许使用JavaScript操作CSS的API，通过CSSOM实现动态读取和修改CSS样式，可以通过document.stylesheets查看 构建渲染树(Recalculate Style)：结合DOM树和CSSOM树，计算 DOM 树中每个节点的样式，涉及css继承规则和层叠规则，这个阶段最终输出的内容是包含样式的DOM树，每个 DOM 节点的样式，可以在devtools的 ComputedStyle 内查看 构建布局树(Layout)：根据渲染树生成布局树，布局树会计算每个DOM元素的大小和几何位置信息，且布局树中只包含可见节点，如display:none的DOM节点不包含在布局树中。第一次确认元素的大小和位置叫布局，之后对节点大小或位置的重新计算叫做回流 生成渲染层树(Layout): 构建布局树的同时会生成渲染层树，当DOM的LayoutObject在相同的坐标空间时(可以理解为Z轴)，将形成渲染层，渲染层树可以理解为层叠上下文，确保页面元素以正确的顺序显示 生成合成层树(Update Layer Tree)：为一些特殊的渲染层生成合成层，不是合成层的其他渲染层与拥有合成层的第一个父级共享合成层，每个合成层对应一个图层(GraphicsLayer)，可以在Devtools-Layers面板查看当前的所有图层 绘制(Paint)：为每个图层(GraphicsLayer)生成绘制列表，用来记录绘制指令和绘制顺序，这些指令在分块光栅化的时候才会被执行 合成层(Composite Layers): 并不是在主线程中合成层，而是把合成层信息提交给合成线程，相当于在合成线程中备份一个图层树，这个操作是同步的，会阻塞主线程。这样做的好处是，有了这份拷贝，合成线程可以不必与主线程交互来进行合成操作。因此，当主线程在进行 Javascript 计算等操作时，合成线程仍然可以正常工作而不被打断。 生成位图：合成线程接手后，将图层分块，然后光栅化图块(将图块转换为位图)，光栅化的方式有两种： 第一种是CPU光栅化：通过光栅化线程池将图块绘制进位图，再将位图作为纹理上传到GPU 第二种是GPU光栅化：浏览器开启了GPU硬件加速，光栅化线程池会将光栅化指令提交给GPU进程，在GPU进程中进行快速光栅化，并保存在GPU内存 合成：光栅化完成后，所有的纹理都在GPU内存中，GPU会把所有纹理绘制到最终的一个位图里，从而完成纹理的合并 显示：纹理合并完成后，合成线程会通知浏览器进程，浏览器进程将页面绘制到内存中，最终显示在屏幕上 总结一下，浏览器的渲染机制可以简单理解为“纵向分层，横向分块”。 什么是合成层WebKit将网页一帧的渲染分为绘制和合成两个步骤。绘制是将网页分层绘制为图像的过程，合成是将所有图像混合在一起后显示在屏幕上的过程。 对于显示器来说，无论当前页面有没有发生变化，它在下一帧总是要刷新的，意味着系统需要提供一个完整的屏幕内容供显示器显示，在这样的场景下，把网页分层，当只有其中一层的内容发生变化时，只用对变化的层执行绘制操作，然后与上一帧中没有变化的图层进行合成，就可以得到最终整个屏幕的内容，避免了绘制操作，与绘制相比，合成是很轻量级的操作，尤其是对于GPU来说。 图层基本都由浏览器去管理，开发者通常不会去干涉，但浏览器回流和重绘的代价很大，在一些情况下合成层能大大提高绘制效率： 合成层可以减少绘制区域，当需要重绘时，只需要合成层重绘，其他层不受影响 利用GPU高效实现滚动、3D变换等动画效果，这些动画的执行过程不需要主线程的参与，在纹理合成前，使用 3D API 对合成层进行变形 在Chrome DevTools查看合成层layer面板 show layer border Performance 生成合成层的原因(Compositing Reason)生成合成层的原因有很多，如果想知道全部情况还是需要参考源码，或者参考这边文章Chromium网页Graphics Layer Tree创建过程分析，下面列出一些常见的从渲染层提升为合成层的原因： 直接提升 硬件加速的iframe元素，video元素，3D canvas元素，2D加速的canvas元素，硬件加速插件(如flash) 3D变换 transform：translateZ(0)，translate3d(0,0,0)，rotateX(0deg)，rotateY(0deg)，rotateZ(0deg)，rotate3d(1,1,145deg)，scaleZ(1)，scale3d(1,1,1); backface-visibility`:`hidden; animation:opacity，transform，， filter，backdrop-filter`; transition设置opacity ，transform， filter， backdrop-filter属性的变换，并且被激活状态`; will-change设置为opacity,transform will-change设置为left，top，right，bottom，并且设置position定位属性为relative，absolute，fixed，sticky的元素 在高dpi的显示器上，元素的width和height已知，并且设置position:fixed属性的情况下，元素会自动升为合成层 子元素影响受子元素影响，父元素可能会被提升为合成层，常见的有以下几种情况： 子元素包含合成层，并且自身设置了opacity &lt; 1,transform,mask,filter 子元素宽高超过父元素，父元素的overflow属性为auto或scroll，父元素会被提升为合成层，滚动条也被提升为单独的合成层 子元素是3d变换属性生成的合成层，并且自身具有perspective属性 隐式合成 层叠：从堆叠顺序上来看，为保持正确的渲染顺序，在合成层上一层的元素会被隐式提升为合成层。 如下图所示，第一张图是正确的渲染结果，但如果蓝色块被提升为合成层，绿色不提升的话，绿色块将和它的父元素白色块渲染到图一图层上，导致渲染结果出错，这种情况下只能将绿色也提升合成层。 滚动重叠：浏览器判定该元素在元素滚动时可能会和合成层重叠，就将该元素提升为合成层，示例见层爆炸 假设重叠：元素具有css动画效果，在动画运行期间，动画元素可以重叠其他元素，哪怕目前哪怕视觉上没有重叠，浏览器也会判定假设已经重叠，会将在动画元素之上的元素升级为合成层。 &lt;style> @-webkit-keyframes slide { from { transform: none; } to { transform: translateX(100px); } } .animating { position: fixed; width: 300px; height: 30px; background-color: green; animation: slide 5s alternate linear infinite; } .box { width: 600px; height: 30px; margin-bottom: 5px; position: relative; } &lt;/style> &lt;div class=\"animating\">&lt;/div> &lt;ul> &lt;li class=\"box\">111111111111&lt;/li> &lt;li class=\"box\">111111111111&lt;/li> &lt;li class=\"box\">111111111111&lt;/li> &lt;li class=\"box\">111111111111&lt;/li> &lt;li class=\"box\">111111111111&lt;/li> &lt;li class=\"box\">111111111111&lt;/li> &lt;li class=\"box\">111111111111&lt;/li> &lt;li class=\"box\">111111111111&lt;/li> &lt;/ul> 层压缩和层爆炸层压缩前面介绍的隐式合成，都很有可能在不知不觉的情况下形成大量的合成层，消耗CPU和内存资源，影响页面性能，浏览器也考虑到了这个问题，会对一些非直接原因创建的合成层进行压缩，避免层爆炸。 下面的例子中，红色块div1通过transform: translateZ(0);将自身提升为合成层，绿色块布局在它上面，为了保持正确的渲染顺序，绿色块div2也被提升为合成层，依次类推，后面的蓝色和紫色div也应该被提升，但是浏览器对这种非直接因素的提升做了优化，将绿蓝紫都放在同一个合成层 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>Document&lt;/title> &lt;style> div { width: 200px; height: 200px; } .box1 { background-color: red; transform: translateZ(0); } .box2 { background-color: green; position:absolute; left: 100px; top: 100px; } .box3 { background-color: blue; position:absolute; left: 150px; top: 150px; } .box4 { background-color: purple; position:absolute; left: 200px; top: 200px; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"box1\">1&lt;/div> &lt;div class=\"box2\">2&lt;/div> &lt;div class=\"box3\">3&lt;/div> &lt;div class=\"box4\">4&lt;/div> &lt;/body> &lt;/html> 层爆炸但还有一些情况，浏览器也无法自动处理压缩，为页面性能埋下隐患，看下面例子，由于滚动元素和合成层重叠，浏览器判定该元素在元素滚动时内部的子元素会和合成层重叠，会将子元素提升为合成层，造成的层爆炸的现象： &lt;style> .animating { position: fixed; width: 300px; height: 30px; background-color: green; } .box { width: 600px; height: 30px; margin-bottom: 5px; position: relative; /* overflow: hidden; */ } &lt;/style> &lt;div class=\"animating\">&lt;/div> &lt;ul> &lt;li class=\"box\">111111111111&lt;/li> &lt;/ul> 使用建议应用场景 合成层的位图会交由 GPU 合成，相比 CPU 处理要快 将动画效果提升到合成层 升级为合成层后，执行transform和opacity动画不会触发回流和重绘，只会触发合成 谨慎使用 每个合成层都会占用内存资源，过度使用合成层会带来反向效果 隐式合成容易在意料之外产生大量合成层，需要特别注意 参考 Chromium网页Graphics Layer Tree创建过程分析 渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的 How_browsers_work GPU Accelerated Compositing in Chrome Front-End Performance Optimization with Accelerated Compositing Part 1 Compositing Layers stick to compositor only properties and manage layer count Browser Rendering Optimization","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://forevehg.github.io/categories/浏览器/"},{"name":"Chrome","slug":"浏览器/Chrome","permalink":"https://forevehg.github.io/categories/浏览器/Chrome/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://forevehg.github.io/tags/浏览器/"},{"name":"Chrome","slug":"Chrome","permalink":"https://forevehg.github.io/tags/Chrome/"}],"keywords":[{"name":"浏览器","slug":"浏览器","permalink":"https://forevehg.github.io/categories/浏览器/"},{"name":"Chrome","slug":"浏览器/Chrome","permalink":"https://forevehg.github.io/categories/浏览器/Chrome/"}]},{"title":"trilium notes基本使用","slug":"trilium notes基本使用","date":"2022-05-28T13:40:02.000Z","updated":"2025-03-17T02:20:40.620Z","comments":true,"path":"2022/05/28/trilium notes基本使用/","link":"","permalink":"https://forevehg.github.io/2022/05/28/trilium notes基本使用/","excerpt":"汉化社区有兄弟做了汉化，点这个 汉化地址","text":"汉化社区有兄弟做了汉化，点这个 汉化地址 导入导出markdown1. 剪贴板导入 2. 文件导入 3. 导出整个目录 4. 导出单个文件 更换主题可以参考自带的主题Steel Blue1. 建一个code 类型为css的文件2. 字体等资源文件可以放在css文件的下面3. 给css文件加上 #appTheme=steel-blue 标签 这时就可以在选项→外观→主题的下拉框中选中Steel Blue这个主题了。 trilium notes的github仓库提供了几个写好的主题，可以点这个链接查看和使用。 很多时候别人预设的主题并不完全符合自己的心意，可以通过自己修改css文件来完善主题样式，trilium给我们提供了开发者工具，在开发者工具中，可以选中某个元素调整它的样式，效果满意后再把代码粘进主题css文件中 新建模板示例中给我们添加了一个 Day template 模板 这个模板会自带一个 TODO的标题，和一个checkbox列表，如果想使用这个模板，需要添加~template=Day template 标签 我们可以建立自己的模板库，放入我们习惯的读书笔记模板，工作会议模板等等，只用在写笔记的时候添加对应的模板标签就可以了 chrome网页保存1. chrome添加扩展程序 Trilium Web Clipper 2. 设置保存路径默认从网页上剪辑的内容都保存在今天日期的日记下，如果想保存在自定义目录，只用在自定义目录中添加#clipperinbox 标签 查看文件保存路径左侧工具栏的图标 → 关于Trilium Notes 插件trilium自身功能有限，但是它提供了插件能力，可以通过插件实现一些它自身没有的功能，比如代码块高亮。 github有一个实现了trilium 代码块高亮的库，点击地址，根据这个库的描述，我们来使用这个它： 新建一个code类型为js的文件，名字随便取 为这个文件添加一个标签 #widget 把highlight.min.js文件附加到上面建好的文件 看一下效果： 脚本添加标签 #run=frontendStartup 隐藏文章标题的示例： api.addButtonToToolbar({ title: '隐藏文章标题', icon: 'low-vision', action: () => { const title = $('.title-row'); if(title.is(':hidden')) { $('.title-row').show(); } else { $('.title-row').hide(); } } })","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://forevehg.github.io/tags/vue/"},{"name":"vue-loader","slug":"vue-loader","permalink":"https://forevehg.github.io/tags/vue-loader/"}],"keywords":[]},{"title":"vue-loader都做了些什么","slug":"vue-loader都做了些什么","date":"2021-05-27T22:45:26.000Z","updated":"2021-06-24T12:34:27.514Z","comments":true,"path":"2021/05/28/vue-loader都做了些什么/","link":"","permalink":"https://forevehg.github.io/2021/05/28/vue-loader都做了些什么/","excerpt":"本文主要内容： vue-loader解析vue单文件组件的过程分析 VueLoaderPlugin的作用","text":"本文主要内容： vue-loader解析vue单文件组件的过程分析 VueLoaderPlugin的作用 1. import一个vue单文件组件时，实际引入是什么新建一个index.vue文件，内容如下： &lt;template> &lt;ul @click=\"handleClick\"> &lt;li v-for=\"item in list\" :key=\"item\">{{ item }}&lt;/li> &lt;/ul> &lt;/template> &lt;script> export default { data() { return { list: ['a', 'b', 'c', 'd', 'e'] }; }, methods: { handleClick() { this.list = ['h', 'i', 'a', 'j', 'k'] }, } }; &lt;/script> &lt;style> ul { color: red; } &lt;/style> 在其他文件中导入 index.vue，并查看输出结果 import app from './index.vue'; console.log(app); 看图可以知道，import 一个单文件组件其实就是导入了这样一个对象。 2. webpack中的loader和plugin webpack 中 loader 的作用是将匹配后缀名的文件从源文件导出为 js 模块，是源文件到 js 模块的转换。 plugin 可以在 webpack 构建过程中插入自定义行为，插件的原型对象上都有一个 apply 方法，这个 apply 方法在安装插件时会被 webpack 编译器调用一次。 众所周知，要想使用 vue 单文件组件，必须在 webpack 中配置 vue-loader 和 vueLoaderPlugin 插件 const VueLoaderPlugin = require('vue-loader/lib/plugin'); module: { rules: [ { test: /\\.vue$/, loader: 'vue-loader', }, ]; } plugins: [new VueLoaderPlugin()]; 3. vue-loader的解析流程1. 从字符串到AST抽象语法树import .vue文件时，会命中vue-loader，第一次调用 vue-loader，原文件首先会被从字符串解析为 AST 抽象语法树，即用普通 js 对象来描述组件中的内容: const { parse } = require('@vue/component-compiler-utils'); const descriptor = parse({ source, //source是loader接收到的源代码字符串 compiler: options.compiler || loadTemplateCompiler(loaderContext), filename, sourceRoot, needMap: sourceMap, }); 调用结果： { template: { type: 'template', content: '\\n' + '&lt;ul @click=\"handleClick\">\\n' + ' &lt;li v-for=\"item in list\" :key=\"item\">{{ item }}&lt;/li>\\n' + '&lt;/ul>\\n', start: 54, attrs: {}, end: 148 }, script: { type: 'script', content: '//\\n' + '//\\n' + '//\\n' + '//\\n' + '//\\n' + '//\\n' + '//\\n' + '//\\n' + '//\\n' + '//\\n' + '\\n' + 'export default {\\n' + ' data() {\\n' + ' return {\\n' + \" list: ['a', 'b', 'c', 'd', 'e']\\n\" + ' };\\n' + ' },\\n' + ' methods: {\\n' + ' handleClick() {\\n' + \" this.list = ['h', 'i', 'a', 'j', 'k']\\n\" + ' },\\n' + ' }\\n' + '};\\n', start: 168, attrs: {}, end: 353, map: { version: 3, sources: [Array], names: [], mappings: ';;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA', file: 'index.vue', sourceRoot: 'src/vue', sourcesContent: [Array] } }, styles: [ { type: 'style', content: '\\nul {\\n color: red;\\n}\\n', start: 7, attrs: {}, end: 35, map: [Object] } ], customBlocks: [], errors: [] } 2. 将AST各部分转换为特殊的引用路径对这个AST的每部分进行处理，.vue文件会被转换为下面这样的代码： //代码1 import { render, staticRenderFns, } from './index.vue?vue&amp;type=template&amp;id=21fec300&amp;'; import script from './index.vue?vue&amp;type=script&amp;lang=js&amp;'; export * from './index.vue?vue&amp;type=script&amp;lang=js&amp;'; import style0 from './index.vue?vue&amp;type=style&amp;index=0&amp;lang=css&amp;'; /* normalize component */ import normalizer from '!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js'; var component = normalizer( script, render, staticRenderFns, false, null, null, null, ); component.options.__file = 'src/vue/index.vue'; export default component.exports; 关注最前面的import语句，在原本的index.vue后面加入了查询条件，包括vue,type,id,lang等，之后将通过不同的查询条件来处理不同部分的代码 3. VueLoaderPlugin插件处理rulesVueLoaderPlugin的主要作用就是对vue不同模块配置不同的loader，在webpack安装插件时，也就是预处理阶段，VueLoaderPlugin的apply会被调用，该方法中拦截了用户自定义的rules属性，加入对 vue 单文件模块处理的规则后，返回调整后的rules列表，看下面的例子： 自定义rules： [ { test: /\\.vue$/, loader: 'vue-loader', }, { test: /\\.css$/, use: ['style-loader', 'css-loader'], }, ]; VueLoaderPlugin处理后的rules： [ { loader: 'xxx/xx/xx/pitcher.js', resourceQuery: [Function: resourceQuery], options: { cacheDirectory: undefined, cacheIdentifier: undefined } }, { use: [ { loader: 'style-loader', options: undefined, ident: undefined }, { loader: 'css-loader', options: undefined, ident: undefined } ], resource: [Function: resource], resourceQuery: [Function: resourceQuery] }, { test: /\\.vue$/, use: [ { loader: 'vue-loader', options: {}, ident: 'vue-loader-options' } ] }, { test: /\\.css$/, use: [ { loader: 'style-loader', options: undefined, ident: undefined }, { loader: 'css-loader', options: undefined, ident: undefined } ] } ] 可以看出自定义的两个 rules 只是对格式进行统一，主要的修改是添加了 pitcher loader, 复用了处理 css 的 loader，重定义了 它们的resource 和 resourceQuery 属性，resourceQuery属性是通过匹配链接中的查询参数来判断链接是否命中。 resourceQuery: 此选项用于测试请求字符串的查询部分（即从问号开始)resource: 简单理解就是匹配到的资源文件的绝对路径 挨个看一下新加的rule: pitcher loader的resourceQuery属性只是简单的匹配第一个查询条件是否是vue resourceQuery: query => { if (!query) { return false } const parsed = qs.parse(query.slice(1)) return parsed.vue != null } 复用的rule，resource 和 resourceQuery具体内容如下 resource: resources => { currentResource = resources return true }, resourceQuery: query => { if (!query) { return false } const parsed = qs.parse(query.slice(1)) if (parsed.vue == null) { return false } if (!conditions) { return false } const fakeResourcePath = `${currentResource}.${parsed.lang}` for (const condition of conditions) { // add support for resourceQuery const request = condition.property === 'resourceQuery' ? query :fakeResourcePath if (condition &amp;&amp; !condition.fn(request)) { return false } } return true } resource只是为了获取当前资源文件的绝对路径，赋值给currentResource resourceQuery简单来说就是将.+查询条件中lang属性作为后缀名添加到当前请求的最末尾，判断这个后缀名是否在rules中配置了对应的loader，如果有loader返回true,否则返回false。 4. 执行pitching loader，生成内联loaderrules列表中目前配置了四个rule，正常情况下loader 总是 从右到左被调用，即import文件时，匹配的顺序是.css -&gt; .vue -&gt; resourceQuery -&gt; pitcher resourceQuery，但这组的第一个loader定义了pitch方法： //pitcher.js module.exports = code => code module.exports.pitch = function (remainingRequest) { //code } 查看文档上关于pitching loader的介绍 loader 总是 从右到左被调用。有些情况下，loader 只关心 request 后面的 元数据(metadata)，并且忽略前一个 loader 的结果。在实际（从右到左）执行 loader 之前，会先 从左到右 调用 loader 上的 pitch 方法。 重点是会先从左到右调用 loader 上的 pitch 方法，举个例子，当执行这句代码时， import { render, staticRenderFns, } from './index.vue?vue&amp;type=template&amp;id=21fec300&amp;'; 执行顺序可以看做是： |- pitcher-loader `pitch` |- resourceQuery-loader `pitch` //匹配了resourceQuery |- vue-loader `pitch` |- css-loader `pitch` |- requested module is picked up as a dependency |- css-loader normal execution |- vue-loader normal execution |- resourceQuery-loader normal execution |- pitcher-loader normal execution 在这里参数?vue命中了pitcher loader的resourceQuery，执行pitcher loader的pitch方法，这个方法根据参数type来生成内联lodaer,如type=template执行完pitch会返回值： export * from \"-!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&amp;type=template&amp;id=21fec300&amp;\" 这个阶段中，如果某个 loader 在 pitch 方法中返回一个结果，那么这个过程会回过身来，并跳过剩下的 loader。也就是只会执行 |- pitcher-loader `pitch` 其他import语句中带有?vue&amp;type=xxx&amp;lang=xxx&amp;&#39;的链接都是同理，最终都会被转换为如上所示的一段内联loader 5. 执行内联loader内联loader按照从右到左的顺序执行，还看上面的例子,export &#39;./index.vue?vue&amp;type=template&amp;id=21fec300&amp;&#39;的loader是vue-loader/lib/index.js,因为链接查询条件中带有type属性，直接命中下面这段代码 // if the query has a type field, this is a language block request // e.g. foo.vue?type=template&amp;id=xxxxx // and we will return early if (incomingQuery.type) { return selectBlock( descriptor, loaderContext, incomingQuery, !!options.appendExtension ) } 返回template部分的代码 &lt;ul @click=\"handleClick\"> &lt;li v-for=\"item in list\" :key=\"item\">{{ item }}&lt;/li> &lt;/ul> 这段代码会传入loaders/templateLoader.js被解析，templateLoader使用vue-template-compiler将html代码转换为render和staticRenderFns，最终用exports 导出，这也是为什么vue-cli文档上要求将vue-loader和vue-template-compiler一起安装的原因。 你应该将 vue-loader 和 vue-template-compiler 一起安装——除非你是使用自行 fork 版本的 Vue 模板编译器的高阶用户 vue单文件组件中的不同模块都是按照这种模式使用对应的loader来处理，回看代码1，import都导入完成之后，执行normalizer方法，将script标签中定义的data,methods等对象和render,staticRenderFns组装在同一个对象中返回，这就是导入一个单文件组件的大致流程。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://forevehg.github.io/tags/vue/"},{"name":"vue-loader","slug":"vue-loader","permalink":"https://forevehg.github.io/tags/vue-loader/"}],"keywords":[]},{"title":"Vue源码阅读——从单文件组件到dom渲染","slug":"Vue源码阅读——从单文件组件到dom渲染","date":"2021-05-03T02:30:01.000Z","updated":"2021-06-24T12:35:22.136Z","comments":true,"path":"2021/05/03/Vue源码阅读——从单文件组件到dom渲染/","link":"","permalink":"https://forevehg.github.io/2021/05/03/Vue源码阅读——从单文件组件到dom渲染/","excerpt":"导入一个单文件组件并用 console.log 输出，可以看到就是导入了如下这样的对象：","text":"导入一个单文件组件并用 console.log 输出，可以看到就是导入了如下这样的对象： 渲染单文件组件： new Vue({ el: '#app', render: (h) => h(app), }); h 函数就是$createElement函数，$createElement 函数的第一个参数应该是 tag，也就是渲染单文件组件时，传入的 tag 是一个如上图的对象，$createElement 的处理也很直接，如果 tag 不是 string 类型的话，直接去 createComponent： if (typeof tag === 'string') { //... } else { vnode = createComponent(tag, data, context, children); //主要关注tag参数 } 通过赋值的变量名知道，createComponent 是返回了一个 vnode 对象，看一下具体处理： function createComponent(Ctor, data, context, children) { //Ctor对应调用时传入的tag const baseCtor = context.$options._base; //在initGlobalAPI时被赋值为Vue实例 if (isObject(Ctor)) { Ctor = baseCtor.extend(Ctor); //创建Vue的子类 } data = data || {}; installComponentHooks(data); return new VNode( `vue-component-${Ctor.cid}`, data, undefined, undefined, undefined, context, { Ctor, /*其他*/ }, ); } extend 函数是创建 Vue 的子类，创建 VNode 实例时第七个参数是 componentOptions，将这个子类包含进去了，之后会用到，这里先知道 createComponent 实际就是返回了一个 vnode，可以理解为这里生成vnode是一个组件的占位vnode。 生成 vnode 后，下一步就是去 patch，看下面的代码(简化后) function (oldVnode, vnode) { const insertedVnodeQueue = [] if (isUndef(oldVnode)) { createElm(vnode, insertedVnodeQueue) } else { const isRealElement = isDef(oldVnode.nodeType) if (isRealElement) { oldVnode = emptyNodeAt(oldVnode) } const oldElm = oldVnode.elm; const parentElm = nodeOps.parentNode(oldElm) createElm(vnode, insertedVnodeQueue, parentElm, nodeOps.nextSibling(oldElm)) if (isDef(parentElm)) { removeVnodes([oldVnode], 0, 0) } } return vnode.elm } 第一次挂载，这里的 oldVnode 就是#app 元素，它是一个真实的 dom 节点，会创建一个空的 vnode，然后执行 createElm： function createElm(vnode, insertedVnodeQueue, parentElm, refElm) { if (createComponent(vnode, parentElm, refElm)) { return; } } function createComponent(vnode, parentElm, refElm) { let i = vnode.data; if (isDef(i)) { if (isDef((i = i.hook)) &amp;&amp; isDef((i = i.init))) { i(vnode); if (vnode.componentInstance) { initComponent(vnode); insert(parentElm, vnode.elm, refElm); } return true; } } } function initComponent(vnode) { vnode.elm = vnode.componentInstance.$el } i.init方法： const componentVNodeHooks = { init(vnode) { const child = vnode.componentInstance = new vnode.componentOptions.Ctor({ _isComponent: true, _parentVnode: vnode, parent }) child.$mount(); return child; } } 上述都是简化后的代码，步骤就是根据上面使用extend创建Vue子类创建组件实例，并调用$mount挂载。 挂载的过程首先会调用render生成vnode，这次调用render，将会调用组件真正的render，获取组件的vnode树，因为是第一次挂载，patch的过程中直接生成dom节点，子节点插入父节点，组成dom树，patch方法最终返回的vnode.elm，就是真实的dom树，它将被复制给组件实例的$el属性，组件实例的$el属性又会在组件挂载结束后被赋值给组件占位vnode的elm属性，最终插入#app节点，完成组件的渲染","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://forevehg.github.io/tags/vue/"},{"name":"源码","slug":"源码","permalink":"https://forevehg.github.io/tags/源码/"}],"keywords":[]},{"title":"Vue源码阅读——从render函数到dom渲染","slug":"Vue源码阅读——从render到dom渲染","date":"2021-05-01T01:02:10.000Z","updated":"2021-06-24T12:35:05.526Z","comments":true,"path":"2021/05/01/Vue源码阅读——从render到dom渲染/","link":"","permalink":"https://forevehg.github.io/2021/05/01/Vue源码阅读——从render到dom渲染/","excerpt":"大部分源码解析的文章都是从项目结构开始，然后再从入口处跟着它的执行流程一步步分析，但我发现那不适合我，很容易看着看着就不知道自己在看什么，我的方法是带着问题出发，先把自己想知道的点拆解成一个个问题，由浅入深，多次有选择的去看源码，每次只关注一个问题，解决一个问题后再继续下一个，最后再回过头来总结整体","text":"大部分源码解析的文章都是从项目结构开始，然后再从入口处跟着它的执行流程一步步分析，但我发现那不适合我，很容易看着看着就不知道自己在看什么，我的方法是带着问题出发，先把自己想知道的点拆解成一个个问题，由浅入深，多次有选择的去看源码，每次只关注一个问题，解决一个问题后再继续下一个，最后再回过头来总结整体 考虑下面的代码 new Vue({ el: '#app', render: (h) => { return h( 'div', { id: 'test', }, 'hello world', ); }, }); 上面这段 vue 代码，最终会生成下面的 dom 结构并渲染到页面上 &lt;div id=\"test\">hello world&lt;/div> 很显然 render 方法中传入的这个 h 参数是一个函数，这个函数可以将标签 div，属性 id，内容 hello world 转换成 dom 元素，看一下 vue 源码中的处理，注意这里简化源码但不破坏源码的结构： vue/src/core/instance/index.js function Vue(options) { this._init(options); } initMixin(Vue); lifecycleMixin(Vue); renderMixin(Vue); 在new Vue()时会调用实例的_init 方法，这个方法挂载在 Vue 原型上 vue/src/core/instance/init.js export function initMixin(Vue) { Vue.prototype._init = function (options) { const vm = this; vm.$options = options; //简化了源码中对用户传入options的处理 initRender(vm); //initRender在实例上绑定render相关的代码，这里主要关注$createElement方法 if (vm.$options.el) { //第一次挂载时将执行到这里，vm.$options.el即 ”el: '#app'“ vm.$mount(vm.$options.el); } }; } vue/src/core/instance/render.js export function initRender(vm) { vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true); } vue/src/core/vdom/create-element.js function createElement(vm, tag, data, children) { children = normalizeChildren(children); return new VNode(tag, data, children); } 暂时只用知道，initRender在实例上绑定$createElement方法，调用vm.$createElement方法，会返回一个 VNode 实例，继续往下走，第一次渲染时，如果options中传入了 el 参数，会自动执行实例上的$mount方法，否则需要自己手动调用: //传入el参数，自动挂载 new Vue({ el: '#app', render: (h) => h('div'), }); //手动挂载 var app = new Vue({ render: (h) => h('div) }) app.$mount('#app') 继续看$mount方法： import Vue from 'core/index'; import { mountComponent } from 'core/instance/lifecycle'; import { query } from 'web/util/index'; Vue.prototype.$mount = function (el) { el = el &amp;&amp; inBrowser ? query(el) : undefined; //query方法就是根据el选择器获取dom元素 const vm = this; vm.$el = query(el) return mountComponent(this, el); }; export function mountComponent(vm, el) { vm._update(vm._render()); } vue/src/core/instance/render.js export function renderMixin(Vue) { Vue.prototype._render = function () { const { render } = vm.$options; //这里解构出来的render就是new Vue时传入的render let vnode; vnode = render.call(vm._renderProxy, vm.$createElement); //vm._renderProxy可以暂看做vm本身 return vnode; }; } 我们都知道，render函数的参数为h，从render.call(vm._renderProxy, vm.$createElement)看出，参数h就是vm.$createElement方法，这个方法最终返回VNode，有一个很妙的地方是h的第三个参数children, 看下面的代码： h( 'div', {}, [ h('ul', {}, [ h('li', {}, 1), h('li', {}, 2) ]), 'hello', 'world' ] ) children的每一项都是h()的调用结果，也就是vnode对象，vue文档中说children是 {String | Array} 子级虚拟节点 (VNodes)，由 createElement() 构建而成， 也可以使用字符串来生成“文本虚拟节点”。可选。 这样的写法直接构造了vnode树，是diff算法、dom挂载的基础。 继续之前的代码，_render的返回值是一个vnode，传入_update中，_update主要调用patch对比上一次渲染的vnode和本次渲染的vnode，由于是第一次渲染，不存在上一次的vnode，所以对比vm.$el和本次vnode export function lifecycleMixin(Vue) { Vue.prototype._update = function (vnode) { const vm = this; vm.__patch__(vm.$el, vnode); //vm.$el是dom元素，在$mount中被赋值 }; } Vue.prototype.__patch__ = function (oldVnode, vnode) { const insertedVnodeQueue = []; const isRealElement = isDef(oldVnode.nodeType); //判断是否是dom元素 if (isRealElement) { oldVnode = emptyNodeAt(oldVnode); //根据dom元素的tag创建VNode } const oldElm = oldVnode.elm; const parentElm = nodeOps.parentNode(oldElm); //获取父元素 createElm(vnode, insertedVnodeQueue, parentElm, nodeOps.nextSibling(oldElm)); if (isDef(parentElm)) { removeVnodes([oldVnode], 0, 0); } }; vue/src/core/vdom/patch.js function emptyNodeAt(elm) { return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm) } function createElm(vnode, insertedVnodeQueue, parentElm, refElm) { if (vnode.tag) { vnode.elm = nodeOps.createElement(vnode.tag, vnode) createChildren(vnode, vnode.children, insertedVnodeQueue) insert(parentElm, vnode.elm, refElm) } else { vnode.elm = nodeOps.createTextNode(vnode.text); insert(parentElm, vnode.elm, refElm) } } function createChildren(vnode, children, insertedVnodeQueue) { if (Array.isArray(children)) { for (let i = 0; i &lt; children.length; i++) { createElm(children[i], insertedVnodeQueue, vnode.elm) } } else if (isPrimitive(vnode.text)) { nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text))) } } function insert(parent, elm, ref) { if (isDef(parent)) { if (isDef(ref)) { if (nodeOps.parentNode(ref) == parent) { nodeOps.insertBefore(parent, elm, ref) } } else { nodeOps.appendChild(parent, elm) } } } 以上是大部分简化的代码，VNode对象的代码可以查看源码，很好理解，另外关于nodeOps的代码这里不列出来了，就是对dom元素的操作，根据名字很容易理解。 很清晰的可以看出，从createElm开始深度遍历vnode树，从上到下遍历时创建dom元素，回溯时再从下到上将子dom节点插入父节点，最终根vnode的elm属性就是完整的dom结构，最终插入$el元素的父元素上，在本例子中就是body元素，至此页面上就会渲染出dom元素了。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://forevehg.github.io/tags/vue/"},{"name":"源码","slug":"源码","permalink":"https://forevehg.github.io/tags/源码/"}],"keywords":[]},{"title":"HTML查漏补缺","slug":"HTML查漏补缺","date":"2020-11-04T13:02:10.000Z","updated":"2025-03-17T02:39:52.571Z","comments":true,"path":"2020/11/04/HTML查漏补缺/","link":"","permalink":"https://forevehg.github.io/2020/11/04/HTML查漏补缺/","excerpt":"","text":"1. a标签a标签可以调起系统自带的电话和发送邮件功能&lt;a href=\"tel:+18500000000\">&lt;/a> &lt;a href=\"mailto:123456@163.com\">&lt;/a> a标签不能嵌套a标签HTML规范中，标签不能嵌套另一可交互元素，比如&lt;a&gt;,&lt;button&gt;","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://forevehg.github.io/tags/html/"}],"keywords":[]},{"title":"白话JS观察者模式和发布订阅模式","slug":"白话JS观察者模式和发布订阅模式","date":"2020-10-25T10:12:51.000Z","updated":"2020-10-25T10:25:19.654Z","comments":true,"path":"2020/10/25/白话JS观察者模式和发布订阅模式/","link":"","permalink":"https://forevehg.github.io/2020/10/25/白话JS观察者模式和发布订阅模式/","excerpt":"从对观察者模式和发布订阅模式有疑问开始，连续看了好几篇文章，最后疑惑依然存在，这到底哪里不一样？？进一步研究和思考后才搞明白，我决定用最大白话最直观的代码方式来记录下来，以便未来再次忘记时来翻阅。","text":"从对观察者模式和发布订阅模式有疑问开始，连续看了好几篇文章，最后疑惑依然存在，这到底哪里不一样？？进一步研究和思考后才搞明白，我决定用最大白话最直观的代码方式来记录下来，以便未来再次忘记时来翻阅。 观察者模式和发布订阅模式最大的区别就是调度的方式不同，观察者模式是由目标直接调度，发布订阅模式由调度中心调度，这句话比较抽象，用最简单的代码表现一下大概是下面这样： 纯享版观察者模式 var Subject = { observers: [], //观察者列表 add(callback) { //添加观察者 this.observers.push(callback); }, remove() {}, //移除观察者 notify() { //通知所有观察者 this.observers.forEach((fn) => fn()); }, }; 纯享版发布订阅模式 var Event = { _listeners: {}, //订阅通道 on: function (eventName, callback) { if (!this._listeners[eventName]) this._listeners[eventName] = []; this._listeners[eventName].push(callback); }, emit: function (eventName) { if (this._listeners[eventName]) { this._listeners[eventName].forEach((callback) => { callback(...[].slice.call(arguments, 1)); }); } }, }; //测试 Event.on('test', function (result) { console.log(result); }); Event.on('test', function () { console.log('test'); }); Event.emit('test', 'hello world'); // 输出 'hello world' 和 'test' 从上面两个纯享版代码可以看出来，观察者模式就是维护一个观察者列表，当需要时，直接广播通知(遍历整个观察者列表)；发布订阅模式是维护一个订阅通道，所谓订阅通道就是一个按事件名称存储订阅列表的地方，当某个事件名称被触发时，会在订阅通道中查找对应的订阅者列表，所以说白了发布订阅模式就是若干个观察者模式的集合，这样够直白了吧。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://forevehg.github.io/tags/设计模式/"}],"keywords":[]},{"title":"从前端角度记录superset二次开发","slug":"superset二次开发","date":"2020-08-07T03:26:12.000Z","updated":"2021-06-24T12:34:01.859Z","comments":true,"path":"2020/08/07/superset二次开发/","link":"","permalink":"https://forevehg.github.io/2020/08/07/superset二次开发/","excerpt":"项目里 superset 版本是 0.36.0, python 版本是 3.6, 网上大部分资料都是后端开发人员贡献的，这篇文章我从一个前端的角度记录一下 superset 二次开发遇到的一些问题和解决方法。","text":"项目里 superset 版本是 0.36.0, python 版本是 3.6, 网上大部分资料都是后端开发人员贡献的，这篇文章我从一个前端的角度记录一下 superset 二次开发遇到的一些问题和解决方法。先讲一下项目的大概结构： 整个项目的后台代码使用了 python，这部分放在项目根目录的 superset 目录下 一整个后台的框架页面使用了 jinjia2，在项目根目录/superset/templates 下查看 页面上图表相关的展示和操作使用了 react，在/superset-frontend 目录下查看 前端打包后的页面放在/superset/static 目录下 1. 修改/添加生成图表的表单项src/explore目录中都是生成图表的表单项相关的代码，如果想添加一项只用在src/explore/controls.jsx文件中，模拟controls对象中的一项去添加一个属性，如添加一个’all_columns_x’ all_columns_x: { type: 'SelectControl', //可以在explore/components/controls目录中找到对应的组件 label: 'X', default: null, description: t('Columns to display'), mapStateToProps: state => ({ choices: columnChoices(state.datasource), }), }, 2. 修改透视表(Pivot Table)中的默认排序列3. 透视表表头和表内容列错位4. 修改默认语言为中文修改superset/config.py文件 BABEL_DEFAULT_LOCALE = \"zh\" 5. 添加新菜单、菜单跳转到新页面找到 navbar_menu.html添加菜单涉及到权限，需要后台开发人员配合，可以先避开权限问题，让添加的菜单显示出来，完成前端部分工作。 打开 superset/templates/appbuilder/navbar_menu.html 文件，如果 appbuilder 下没有 navbar_menu.html，可以到本地安装的 superset 目录下找，比如我的 superset 装在/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/superset/下，那就可以到这个目录找 templates/appbuilder/navbar_menu.html，在修改过程中遇到项目中没有的 html 文件都是这样操作，找到后如果需要修改这个 html 文件，可以把它复制到自己项目的对应文件夹下。 修改 navbar_menu.html 文件is_menu_visible是用来过滤菜单的，先把它注释掉 {% for item1 in menu.get_list() %} &lt;!-- is_menu_visible --> {% if item1 | is_menu_visible %} {% if item1.childs %} &lt;li class=\"dropdown\"> &lt;a class=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"javascript:void(0)\" target=\"_blank\" rel=\"noopener\"> {% if item1.icon %} &lt;i class=\"fa {{item1.icon}}\">&lt;/i>&amp;nbsp; {% endif %} {{_(item1.label)}}&lt;b class=\"caret\">&lt;/b>&lt;/a> &lt;ul class=\"dropdown-menu\"> {% for item2 in item1.childs %} {% if item2 %} {% if item2.name == '-' %} {% if not loop.last %} &lt;li class=\"divider\">&lt;/li> {% endif %} &lt;!-- | is_menu_visible --> {% elif item2 | is_menu_visible %} &lt;li>{{ menu_item(item2) }}&lt;/li> {% endif %} {% endif %} {% endfor %} &lt;/ul> &lt;/li> {% else %} &lt;li>{{ menu_item(item1) }}&lt;/li> {% endif %} {% endif %} {% endfor %} &lt;/ul>&lt;/li> 添加菜单修改 superset/app.py 文件 appbuilder.add_link( \"New Menu\", label=__(\"New Menu\"), href=\"/superset/new\", icon=\"fa-cloud-upload\", category=\"New\", category_label=__(\"New\"), category_icon=\"fa-wrench\", ) 添加处理函数修改 superset/views/core.py 文件， 在class Superset下添加 @has_access @expose(\"/new\", methods=[\"GET\", \"POST\"]) def doudizhu_events(self): \"\"\"SQL Editor\"\"\" bootstrap_data = json.dumps({}) return self.render_template( \"superset/basic.html\", entry=\"new\", bootstrap_data=bootstrap_data ) 在class Superset中定义的处理函数根路径都是/superset,所以现在就有了一个/superset/new的路径，与上面add_link的href属性对应，这里的entry=&quot;new&quot;指向的是 react 的入口文件 添加入口文件修改/superset-frontend/webpack.config.js文件，在 config.entry 下添加新的入口 entry: { theme: path.join(APP_DIR, \"/src/new/index.jsx\"); } 在对应的/src/new下添加index.jsx文件，可以仿照superset-frontend/src/addSlice下的文件 index.js import React from \"react\"; import ReactDOM from \"react-dom\"; import App from \"./App\"; ReactDOM.render(&lt;App />, document.getElementById(\"app\")); App.jsx import React from \"react\"; import { hot } from \"react-hot-loader/root\"; import setupApp from \"../../setup/setupApp\"; import setupPlugins from \"../../setup/setupPlugins\"; import New from \"./New\"; setupApp(); setupPlugins(); const appContainer = document.getElementById(\"app\"); const bootstrapData = JSON.parse(appContainer.getAttribute(\"data-bootstrap\")); const App = () => &lt;New datasources={bootstrapData.datasources} />; export default hot(App); 编写组件代码New.jsx 中就是正常的 react 组件代码 6. 添加新图例，引入 echarts参考 以添加一个简单的折线图为例 在 superset-frontend/src/visualizations/ 目录下新建文件夹 SimpleLine，在 SimpleLine 文件夹下新建 images 文件夹,images 文件夹中放 SimpleLine 这个新图例的的缩略图，然后继续在 SimpleLine 文件夹下新建 SimpleLine.jsx,SimpleLinePlugin.js,transformProps.js， 新建 SimpleLinePlugin.jsimport { t } from \"@superset-ui/translation\"; import { ChartMetadata, ChartPlugin } from \"@superset-ui/chart\"; import transformProps from \"./transformProps\"; import thumbnail from \"./images/thumbnail.png\"; const metadata = new ChartMetadata({ name: t(\"Simple Line\"), description: \"\", thumbnail, }); export default class SimpleLinePlugin extends ChartPlugin { constructor() { super({ metadata, transformProps, loadChart: () => import(\"./SimpleLine.jsx\"), }); } } 新建 transformProps.js这个文件单纯的用来转换数据，可以在这里把从后端接收到的数据处理成前端展示需要的格式 export default function transformProps(chartProps) { const { height, width, datasource, formData, queryData, rawFormData, } = chartProps; const { records, columns } = queryData.data; return { width, height, data: records, columns: columns, columns_x: rawFormData.all_columns_x, columns_y: rawFormData.all_columns_y, }; } 新建 SimpleLine.jsx这部分代码我只放了个大概，主要做的工作就是通过 props 接收参数，然后导入echarts-for-react并使用，关于 echarts 的配置，直接参考 echarts 文档。 import React from \"react\"; import PropTypes from \"prop-types\"; import ReactEcharts from \"echarts-for-react\"; const propTypes = { data: PropTypes.array, columns: PropTypes.columns, width: PropTypes.number, height: PropTypes.number, columns_x: PropTypes.string, columns_y: PropTypes.string, }; //检查类型，其中data包含viz.py中返回的数据，width和height为图表宽高 class SimpleLine extends React.PureComponent { render() { const options = { xAxis: { type: \"category\", data: [], }, yAxis: { type: \"value\", }, series: [ { name: yName, data: [], type: \"line\", }, ], }; return ( &lt;ReactEcharts option={options} style={{ height: this.props.height }} >&lt;/ReactEcharts> ); } } SimpleLine.displayName = \"simple line\"; SimpleLine.propTypes = propTypes; export default SimpleLine; 修改文件/superset-frontend/src/setup/setupPlugins.ts// 文件开头导入SimpleLine import SimpleLine from '../explore/controlPanels/SimpleLine'; //注册SimpleLine,在getChartControlPanelRegistry()方法的链式调用后追加一句 .registerValue('simple_line', SimpleLine) 修改文件/superset-frontend/src/visualizations/presets/MainPreset.js//导入 import SimpleLineChartPlugin from \"../SimpleLine/SimpleLinePlugin\"; //在plugins后添加 new SimpleLineChartPlugin().configure({ key: \"simple_line\" }); 后端代码添加 class SimpleLine修改/superset/viz.py文件,在viz_types的定义前添加class SimpleLine,下面这段代码根据你需要的数据自行进行处理，这里只做最简单的演示 class SimpleLine(BaseViz): viz_type = 'simple_line' verbose_name = \"simple line\" sort_series = False is_timeseries = False def query_obj(self): d = super().query_obj() fd = self.form_data #form_data中包含界面左侧组件内容 columns = [] if not fd.get('all_columns'): #这个字段对应×××组件，不为空 raise Exception('Choose Columns') if fd.get('all_columns'): d['columns'] = columns # all_columns是左侧组件名，后面会提到 return d def get_data(self, df): # df是pandas的DataFrame类型 data = np.array(df).tolist() #假设数据很简单，不需要做别的处理 # 如果除了绘图用的数据还有别的信息，可以构造一个字典来返回 # data = {'plot_data':plot_data,'other_info':other_info} return self.handle_js_int_overflow( dict(records=df.to_dict(orient=\"records\"), columns=list(df.columns)) ) 这样就大功告成了。 7. 三级菜单菜单的修改都需要注意，登录成功后进入的welcome页面和其他页面使用的模板不一样，welcome页面的菜单是通过react代码写的，写两套的用意大概是向开发者展示两种写法，我们可以使用其中一种，如果两种都用了， 在修改菜单时需要注意两处都要修改： superset/templates/appbuilder/navbar_menu.html{% for item1 in menu.get_list() %} {% if item1 | is_menu_visible %} {% if item1.childs %} &lt;li class=\"dropdown\"> &lt;a class=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"javascript:void(0)\" target=\"_blank\" rel=\"noopener\"> {% if item1.icon %} &lt;i class=\"fa {{item1.icon}}\">&lt;/i>&amp;nbsp; {% endif %} {{_(item1.label)}}&lt;b class=\"caret\">&lt;/b>&lt;/a> &lt;ul class=\"dropdown-menu\"> {% for item2 in item1.childs %} {% if item2 %} {% if item2.childs %} &lt;li class=\"dropdown-submenu\" style=\"position:relative\"> &lt;a class=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"javascript:void(0)\" target=\"_blank\" rel=\"noopener\"> {% if item2.icon %} &lt;i class=\"fa {{item2.icon}}\" style=\"width: 18px; text-align: center;\">&lt;/i>&amp;nbsp; {% endif %} {{_(item2.label)}}&lt;b class=\"fa fa-chevron-right\" style=\"margin-left:10px\">&lt;/b>&lt;/a> &lt;ul class=\"dropdown-menu\" style=\"left: 100%;top: -3px;\"> {% for item3 in item2.childs %} {% if item3 %} {% if item3.name == '-' %} {% if not loop.last %} &lt;li class=\"divider\">&lt;/li> {% endif %} {% elif item3 %} &lt;li>{{ menu_item(item3) }}&lt;/li> {% endif %} {% endif %} {% endfor %} &lt;/ul> &lt;/li> {% else %} {% if item2.name == '-' %} {% if not loop.last %} &lt;li class=\"divider\">&lt;/li> {% endif %} {% elif item2 | is_menu_visible %} &lt;li>{{ menu_item(item2) }}&lt;/li> {% endif %} {% endif %} {% endif %} {% endfor %} &lt;/ul>&lt;/li> {% else %} &lt;li> {{ menu_item(item1) }} &lt;/li> {% endif %} {% endif %} {% endfor %} &lt;/ul>&lt;/li>&lt;/ul>&lt;/li> &lt;NavDropdown id={`menu-dropdown-${label}`} eventKey={index} title={navTitle} className={className} > {childs.map((child, index1) => //新添加，递归多级菜单 child.childs &amp;&amp; child.childs.length > 0 ? ( &lt;MenuObject {...child} className=\"right_menu_wrap\" /> ) : child === '-' ? ( &lt;MenuItem key={`$${index1}`} divider /> ) : ( &lt;MenuItem key={`${child.label}`} href={child.url} eventKey={parseFloat(`${index}.${index1}`)} > &lt;i className={`fa ${child.icon}`} /> &amp;nbsp; {child.label} &lt;/MenuItem> ), )} &lt;/NavDropdown> 添加js和css修改文件superset/templates/appbuilder/baselayout.html&lt;script type=\"text/javascript\"> $(document).ready(function () { $('.dropdown-submenu').hover(function () { $(this).children('ul').show() }, function () { $(this).children('ul').hide() }) }); &lt;/script> 修改文件superset/templates/superset/basic.html&lt;style> .dropdown-submenu { position: relative; } .dropdown-submenu:hover>.dropdown-menu { display: block; left: 100%; top: 0; } .fa { width: 18px; text-align: center; } &lt;/style> 8. 修改看板tab的选项卡最大数量目录：superset-frontend/src/dashboard/components/gridComponents/Tabs.jsx，修改MAX_TAB_COUNT 9. 扩展看板能保存的最长字符修改superset/config.py下的SUPERSET_DASHBOARD_POSITION_DATA_LIMIT字段 9. 解决在看板中快速切换筛选条件导致的数据错乱（自定义图例）解决方法： 中断请求 记录上一次请求的时间，并将时间作为参数传到后台，请求成功后，后台返回的数据中返回请求时传入的时间，对比两次时间，如果不一致，丢弃请求结果 10. 修改翻译文件后更新看不到效果翻译文件修改后需要编译，将.po文件编译为.mo文件才会生效 cd ~/superset/superset/translations/zh/LC_MESSAGES msgfmt ./messages.po -o ./messages.mo 11. 修改页面默认筛选条件举个例子，比如数据表页面，默认的显示的筛选条件是表名/以开始，但最常用的是表名/包含，想让页面默认筛选条件显示表名/包含，只用修改配置文件中链接地址，在superset/app.py文件下找到指定页面的菜单修改： appbuilder.add_link( \"Tables\", label=__(\"Tables\"), href=\"/tablemodelview/list/?_flt_2_table_name\", icon=\"fa-table\", category=\"Sources\", category_label=__(\"Sources\"), category_icon=\"fa-table\", ) 这里主要修改_flt_2_table_name，其中的数字表示的是筛选条件下拉列表中选项的下标，其中包含的下标是2，所以改为_flt_2_table_name","categories":[],"tags":[{"name":"superset","slug":"superset","permalink":"https://forevehg.github.io/tags/superset/"},{"name":"react","slug":"react","permalink":"https://forevehg.github.io/tags/react/"}],"keywords":[]},{"title":"理解Echarts配置项","slug":"学习Echarts配置项","date":"2020-07-01T02:47:54.000Z","updated":"2020-07-02T06:37:34.674Z","comments":true,"path":"2020/07/01/学习Echarts配置项/","link":"","permalink":"https://forevehg.github.io/2020/07/01/学习Echarts配置项/","excerpt":"colorcolor是一个常用的属性，在很多配置项里用来设置填充颜色，color的值有rgb，rgba，16进制的颜色值，还支持渐变和纹理. 渐变纯色很好理解，这里主要说一下渐变，以线性渐变为例","text":"colorcolor是一个常用的属性，在很多配置项里用来设置填充颜色，color的值有rgb，rgba，16进制的颜色值，还支持渐变和纹理. 渐变纯色很好理解，这里主要说一下渐变，以线性渐变为例 //线性渐变的color配置 color: { type: 'linear', // x,y 线的起点 x: 0, y: 0, // x2,y2 线的终点 x2: 0, y2: 1, colorStops: [{ offset: 0, color: 'red' // 0%(线的起点) 处的颜色 }, { offset: 1, color: 'blue' // 100%(线的终点) 处的颜色 }], global: false // 缺省为 false } 那最大的问题就是绘制图形时的坐标了，很容易被误导的点在于绘制出来的坐标系跟绘制图形时的坐标系不是一个东西，看下图，绘制好的图形原点(0,0)位于左下角 // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts2880')); // 指定图表的配置项和数据 var option = { xAxis: { type: 'category', boundaryGap: false, data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [{ data: [820, 932, 901, 934, 1290, 1330, 1320], type: 'line', areaStyle: {} }] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); 但绘制图形时，原点是在左上角的 options = { xAxis: { type: 'category', boundaryGap: false, data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [{ data: [1320, 1320, 1320, 1320, 1320, 1320, 1320], type: 'line', areaStyle: { color: { type: 'linear', // x,y 线的起点在左上角 x: 0, y: 0, // x2,y2 线的终点在左下角 x2: 0, y2: 1, colorStops: [{ offset: 0, color: 'red' // 0%(线的起点) 处的颜色 }, { offset: 1, color: 'blue' // 100%(线的终点) 处的颜色 }], global: false // 缺省为 false } } }] }; 上面的代码，用过ps的人可以想象从左上角到左下角拉渐变线，拉出来就是从红到蓝的垂直渐变了 // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts6125')); // 指定图表的配置项和数据 var option = { xAxis: { type: 'category', boundaryGap: false, data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [{ data: [1320, 1320, 1320, 1320, 1320, 1320, 1320], type: 'line', areaStyle: { color: { type: 'linear', // x,y 线的起点 x: 0, y: 0, // x2,y2 线的终点 x2: 0, y2: 1, colorStops: [{ offset: 0, color: 'red' // 0%(线的起点) 处的颜色 }, { offset: 1, color: 'blue' // 100%(线的终点) 处的颜色 }], global: false // 缺省为 false } } }] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); 水平的线性渐变就是从(0,0) -&gt; (1,0) options = { xAxis: { type: 'category', boundaryGap: false, data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [{ data: [1320, 1320, 1320, 1320, 1320, 1320, 1320], type: 'line', areaStyle: { color: { type: 'linear', // x,y 线的起点在左上角 x: 0, y: 0, // x2,y2 线的终点在左下角 x2: 1, y2: 0, colorStops: [{ offset: 0, color: 'red' // 0%(线的起点) 处的颜色 }, { offset: 1, color: 'blue' // 100%(线的终点) 处的颜色 }], global: false // 缺省为 false } } }] }; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts6524')); // 指定图表的配置项和数据 var option = { xAxis: { type: 'category', boundaryGap: false, data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [{ data: [1320, 1320, 1320, 1320, 1320, 1320, 1320], type: 'line', areaStyle: { color: { type: 'linear', // x,y 线的起点 x: 0, y: 0, // x2,y2 线的终点 x2: 1, y2: 0, colorStops: [{ offset: 0, color: 'red' // 0%(线的起点) 处的颜色 }, { offset: 1, color: 'blue' // 100%(线的终点) 处的颜色 }], global: false // 缺省为 false } } }] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); 依次类推，从左上角到右下角的，(0,0) -&gt; (1,1) // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('echarts9861')); // 指定图表的配置项和数据 var option = { xAxis: { type: 'category', boundaryGap: false, data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [{ data: [1320, 1320, 1320, 1320, 1320, 1320, 1320], type: 'line', areaStyle: { color: { type: 'linear', // x,y 线的起点 x: 0, y: 0, // x2,y2 线的终点 x2: 1, y2: 1, colorStops: [{ offset: 0, color: 'red' // 0%(线的起点) 处的颜色 }, { offset: 1, color: 'blue' // 100%(线的终点) 处的颜色 }], global: false // 缺省为 false } } }] }; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); 纹理color: { image: imageDom, // 支持为 HTMLImageElement, HTMLCanvasElement，不支持路径字符串 repeat: 'repeat' // 是否平铺，可以是 'repeat-x', 'repeat-y', 'no-repeat' }","categories":[],"tags":[{"name":"Echarts","slug":"Echarts","permalink":"https://forevehg.github.io/tags/Echarts/"}],"keywords":[]},{"title":"SVG基础","slug":"SVG基础","date":"2020-06-20T09:45:39.000Z","updated":"2020-07-03T05:42:28.961Z","comments":true,"path":"2020/06/20/SVG基础/","link":"","permalink":"https://forevehg.github.io/2020/06/20/SVG基础/","excerpt":"SVG是可缩放矢量图形的缩写，它使用XML来定义图像，这篇文章记录我学习SVG的过程。","text":"SVG是可缩放矢量图形的缩写，它使用XML来定义图像，这篇文章记录我学习SVG的过程。 SVG和普通的HTML + CSS的绘图方式差别不大，只是刚好弥补了HTML元素在绘制矢量图方面的不足，但原理上都是相同的， SVG的命名空间 SVG的基本标签 SVG坐标系统 SVG绘制基本图形 SVG分组","categories":[],"tags":[{"name":"SVG","slug":"SVG","permalink":"https://forevehg.github.io/tags/SVG/"}],"keywords":[]},{"title":"弹性盒模型之flex属性","slug":"弹性盒模型之flex属性","date":"2019-11-27T00:39:45.000Z","updated":"2025-03-17T06:05:17.810Z","comments":true,"path":"2019/11/27/弹性盒模型之flex属性/","link":"","permalink":"https://forevehg.github.io/2019/11/27/弹性盒模型之flex属性/","excerpt":"flex属性用来设置弹性盒子项的拉伸，收缩和自身主大小，flex的属性值有多种形式，可以为一个值，两个值，或三个值","text":"flex属性用来设置弹性盒子项的拉伸，收缩和自身主大小，flex的属性值有多种形式，可以为一个值，两个值，或三个值 一个值 initial | auto | none | flex-grow | flex-basis 两个值 flex-grow | (flex-shrink | flex-basis) 三个值 flex-grow flex-shrink flex-basis 其中，flex为单数值，initial，auto，none时其实是特定三个值的简写 flex:1 -&gt; flex: 1 1 0; flex:initial -&gt; flex:0 1 auto flex:auto -&gt; flex: 1 1 auto flex:none -&gt; flex: 0 0 auto flex-grow属性值是数值，默认值0，它定义弹性盒子项如何拉伸,当弹性项的flex-basis值相加小于盒子宽度时，弹性项的拉伸生效单个弹性项宽度的计算方式为： 该项basis值 + 该项grow值 * ((总宽度 - basis值总和) / 可拉伸项数量) flex-shrink属性值是数值，默认值1，它定义弹性盒子项如何收缩，当弹性项的flex-basis值相加大于盒子宽度时，弹性项的收缩生效，单个弹性项宽度的计算方式为： flex-basis值 - (basis总和 - 总宽度) 该项basis值 / (第一项shrink值 第一项宽度 + 第二项shrink值 * 第二项宽度….第n项..) flex-basis属性值是一个带宽度单位的数值或是auto,content,initial，默认值auto auto: 表示元素的basis值是自身的width值，在元素的宽度计算中，当弹性盒子有空间拉伸并且flex-grow不等0时，元素宽度等于自身width值加上拉伸值 initial: 元素的basis值是自身的width值，在元素的宽度计算中，元素的宽度保持自身width值，并且flex-grow不算入计算内，也就是说，当flex-basis为initial时，flex-grow不管等于几都可以直接看成0 content：不知道是测试的浏览器不支持还是怎样，在整个测试过程中congtent的表现跟initial的表现一致 下面有几个例子，这些例子公用下面这一段html和css代码 &lt;div id=\"content\"> &lt;div class=\"box1\" style=\"background-color:red;\">&lt;/div> &lt;div class=\"box2\" style=\"background-color:lightblue;\">&lt;/div> &lt;div class=\"box3\" style=\"background-color:yellow;\">&lt;/div> &lt;div class=\"box4\" style=\"background-color:green;\">&lt;/div> &lt;/div> #content { width: 200px; height: 100px; border:1px solid green; display: flex; } #content div { width: 30px; } 第一个例子，当4个div的flex设置为下面四个值时，计算各自的宽度 #content .box1 { flex: 1 auto; } #content .box2 { flex: 2 initial; } #content .box3 { flex: 1 0 80px; } #content .box4 { flex: 0 1 40px; } 首先看所有元素flex-basis的和是否超出盒子的总宽度200px auto和initial就是元素的width,也就是30px,所以 flex-basis的和 = 30px + 30px + 80px + 40px = 180px, 180 &lt; 200可拉伸，不收缩 flex-grow的和 = 2，因为box2的flex-basis值为initial,所以就把它的flex-grow算成是0 box1的宽度 = 30 + 1 * ((200 - 180) / 2) = 40 box2的宽度 = 30 box3的宽度 = 80 + 1 * ((200 - 180) / 2) = 90 box3的宽度 = 40 第二个例子，计算各自的宽度100 #content .box1 { flex: 1 auto; } #content .box2 { flex: 2 initial; } #content .box3 { flex: 1 0 120px; } #content .box4 { flex: 0 1 120px; } 首先看所有元素flex-basis的和是否超出盒子的总宽度200px auto和initial就是元素的width,也就是30px,所以 flex-basis的和 = 30px + 30px + 120px + 120px = 300px, 300 &gt; 200不可拉伸，会收缩, flex-shrink省略时取默认值1，超出的宽度值为100 box1的宽度 = 30 - 100 30 / (1 30 + 1 30 + 0 120 + 1 * 120) = 13.33 box2的宽度 = 同上 = 13.33 box3的宽度 = 不收缩 = 120 box3的宽度 = 120 - 100 120 / (1 30 + 1 30 + 0 120 + 1 * 120) = 53.33","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://forevehg.github.io/tags/CSS/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"为了弄明白Promise的运行顺序，手写一个Promise","slug":"为了弄明白Promise的运行顺序，徒手写一个Promise","date":"2019-10-20T12:39:45.000Z","updated":"2025-03-17T06:05:17.806Z","comments":true,"path":"2019/10/20/为了弄明白Promise的运行顺序，徒手写一个Promise/","link":"","permalink":"https://forevehg.github.io/2019/10/20/为了弄明白Promise的运行顺序，徒手写一个Promise/","excerpt":"最开始我没想去写Promise, 都是因为一道面试题，我开始怀疑自己对Promise有什么误解，或是根本不了解，这还是自己工作中用的挺多的一个东西，感到很惭愧，于是就想去认真了解一下，这道面试题放在下面：","text":"最开始我没想去写Promise, 都是因为一道面试题，我开始怀疑自己对Promise有什么误解，或是根本不了解，这还是自己工作中用的挺多的一个东西，感到很惭愧，于是就想去认真了解一下，这道面试题放在下面： new Promise((resolve, reject) => { resolve(); }).then(() => { console.log(\"promise1 resolved\"); return Promise.resolve(2) }).then((r) => { console.log('----', r) }, error => { console.log('error', error) }) new Promise((resolve, reject) => { resolve(); }).then(() => { console.log(\"promise2 resolved\"); }).then(() => { console.log(\"promise3 resolved\") }).then(() => { console.log(\"promise4 resolved\") }).then(() => { console.log(\"promise5 resolved\") }) 运行结果promise1 resolvedpromise2 resolvedpromise3 resolvedpromise4 resolved—- 2promise5 resolved 在最开始，我认为的运行结果promise1 resolvedpromise2 resolved—- 2promise3 resolvedpromise4 resolvedpromise5 resolved 也就是说，当时我认为return Promise.resolve(2)这句是直接替换掉了包裹它的then返回的promise，连上了后面的then，事实显然不是这样, 在网上看了很多解析，最后还是不是很理解，我就决定自己按照promiseA+规范一个promise来看看到底是怎样的，虽然实现之后发现这跟promiseA+规范没有什么关系。。。 Promise应该接受一个函数，这个函数是立即执行的 function MyPromise(executor) { executor() } 一个Promise的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。promise当前状态为Pending时可以改变为Fulfilled或Rejected,当前状态为Fulfilled或Rejected时不能改变状态 function MyPromise(executor) { this.status = \"pending\"; //默认是pending this.value = null; this.reason = reason; this.resolve = function(value) { if (this.status == \"pending\") { this.value = value this.status = \"fulfilled\" } } this.reject = function(reason) { if (this.status == \"pending\") { this.reason = reason this.status = \"rejected\" } } try { //发生异常后立刻更改Promsie状态为rejected executor(this.resolve, this.reject) } catch (error) { this.reject(error) } } 一个Promise必须提供一个then方法以访问其当前值、终值和据因 //规范：then方法接受两个参数promise.then(onFulfilled, onRejected) MyPromise.prototype.then = function(onFulfilled, onRejected) { //规范：如果 onFulfilled 不是函数，其必须被忽略，如果 onRejected 不是函数，其必须被忽略 onFulfilled = typeof onFulfilled == \"function\" ? onFulfilled : function(x) { return x } onRejected = typeof onRejected == \"function\" ? onRejected : function(e) { return e } //规范：then 方法必须返回一个 promise 对象 return new MyPromise(function() {}) } onFulfilled和onRejected的特性 规范上说onFulfilled在 promise 执行结束后必须被调用，第一个参数为 promise 的终值， onRejected在promise 被拒绝执行后必须调用，第一个参数为 promise 的据因，在promies执行结束前都不能调用，且只能调用一次，promise的resolve或reject被调用是表示promise执行结束了，所以这里要用到观察者模式, 每个promise对象作为主体，在promise.then负责注册事件回调，当promise的状态发生改变时，调用对应状态的回调事件列表。 function MyPromise(executor) { this.status = \"pending\"; //默认是pending this.value = null; this.reason = null; //新增 this.onFulfilleds = []; //完成态的回调事件列表 this.onRejecteds = [] //拒绝态的回调事件列表 this.resolve = function(value) { if (this.status == \"pending\") { this.value = value this.status = \"fulfilled\" //规范：当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调 for (let fn of this.onFulfilleds) { fn() } } } this.reject = function(reason) { if (this.status == \"pending\") { this.reason = reason this.status = \"rejected\" //当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调 for (let fn of this.onRejecteds) { fn() } } } try { //发生异常后立刻更改Promsie状态为rejected executor(this.resolve.bind(this), this.reject.bind(this)) } catch (error) { this.reject(error) } } MyPromise.prototype.then = function(onFulfilled, onRejected) { let self = this; //规范：如果 onFulfilled 不是函数，其必须被忽略，如果 onRejected 不是函数，其必须被忽略 onFulfilled = typeof onFulfilled == \"function\" ? onFulfilled : function(x) { return x } onRejected = typeof onRejected == \"function\" ? onRejected : function(e) { return e } let promise = new MyPromise(function(resolve, reject) { //在promies执行结束前不能调用，当status为pending代表promise还没有执行完,将回调加入对应状态的回调列表 if (self.status == \"pending\") { self.onFulfilleds.push(function() { //规范：onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用 setTimeout(function() { try { let x = onFulfilled(self.value); resolve(x) // PromiseResolve(promise, x) //promise的解决过程 } catch (e) { reject(e) } }) }) self.onRejecteds.push(function() { //规范：onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用，所以将回调函数加入事件循环队列 setTimeout(function() { try { let x = onRejected(self.reason) resolve(x) // PromiseResolve(promise, x) } catch (e) { reject(e) } }) }) } else if (self.status == \"fulfilled\") { //status为fulfilled代表promise已经执行完，直接将回调函数加入事件循环队列 setTimeout(function() { try { let x = onFulfilled(self.value) resolve(x) // PromiseResolve(promise, x) } catch (e) { reject(e) } }) } else if (self.status == \"rejected\") { //status为rejected代表promise已经执行完(被拒绝)，直接将回调函数加入事件循环队列 setTimeout(function() { try { let x = onRejected(self.reason) resolve(x) // PromiseResolve(promise, x) } catch (e) { reject(e) } }) } }) return promise; } Promise解决过程：[Resolve] 在上面的代码中我们在执行了onFulfilled回调后直接决议了then返回的promise对象，但规范中还做了其他处理，当得到回调函数的返回值后，还经历了一个Promise的解决过程，我们来实现以下这个解决过程PromiseResolve let x = onFulfilled(self.value); // resolve(x) //这里不会直接决议，还有一个解决过程，我们叫他PromiseResolve(promise,x),这里的参数promise指的是then中new出来的那个promise function PromiseResolve(promise, x) { //如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise if (promise == x) return promise.reject(new TypeError()) //x为promise，对象或者函数 if (x !== null &amp;&amp; (typeof x == \"object\" || typeof x == \"function\")) { let isCall = false; //标记resolvePromise或rejectPromise是否被调用 try { let then = x.then; //如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise: if (typeof then == \"function\") { then.call(x, function(y) { //如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 if (isCall) return isCall = true //如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y) PromiseResolve(promise, y) }, function(r) { if (isCall) return isCall = true //如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise promise.reject(r) }) } else { //如果 then 不是函数，以 x 为参数执行 promise promise.resolve(x) } } catch (e) { // then 方法抛出了异常 e,如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之 if (isCall) return isCall = true //取x.then抛出异常或者then方法抛出异常以 e 为据因拒绝 promise promise.reject(e) } } else { //如果 x 不为对象或者函数，以 x 为参数执行 promise promise.resolve(x) } } 按照以上代码，运行结果为 promise1 resolved promise2 resolved promise3 resolved -- --2 promise4 resolved promise5 resolved 这个结果与浏览器中的结果仍然不同，似乎是少了一轮，也就是在PromiseResolve解决过程中，x.then函数不是直接执行了，而是被加入了事件队列 function PromiseResolve(promise, x) { //如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise if (promise == x) return promise.reject(new TypeError()) //x为promise，对象或者函数 if (x !== null &amp;&amp; (typeof x == \"object\" || typeof x == \"function\")) { let isCall = false; //标记resolvePromise或rejectPromise是否被调用 try { let then = x.then; //如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise: if (typeof then == \"function\") { setTimeout(function() { //++ then.call(x, function(y) { //如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 if (isCall) return isCall = true //如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y) PromiseResolve(promise, y) }, function(r) { if (isCall) return isCall = true //如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise promise.reject(r) }) }) //++ } else { //如果 then 不是函数，以 x 为参数执行 promise promise.resolve(x) } } catch (e) { // then 方法抛出了异常 e,如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之 if (isCall) return isCall = true //取x.then抛出异常或者then方法抛出异常以 e 为据因拒绝 promise promise.reject(e) } } else { //如果 x 不为对象或者函数，以 x 为参数执行 promise promise.resolve(x) } } 这样运行结果就跟浏览器一致了,但关于最后这点纯属个人看法，反正这一顿操作下来，对promise的理解加深了不少，具体浏览器或node如何实现的欢迎指教~ 这里是完整代码","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://forevehg.github.io/tags/JavaScript/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"HTMLCollection和NodeList","slug":"HTMLCollection和NodeList","date":"2018-05-08T12:21:02.000Z","updated":"2021-04-19T22:21:22.565Z","comments":true,"path":"2018/05/08/HTMLCollection和NodeList/","link":"","permalink":"https://forevehg.github.io/2018/05/08/HTMLCollection和NodeList/","excerpt":"问题和解决过程对这两个概念有疑惑的起因是我想在阿里图标库批量下载当前页面上的图标，但在页面上没找到如何批量加入购物车的功能，在查看了dom结构后我在控制台写了几句代码希望能批量选择这一页的图标，代码如下：","text":"问题和解决过程对这两个概念有疑惑的起因是我想在阿里图标库批量下载当前页面上的图标，但在页面上没找到如何批量加入购物车的功能，在查看了dom结构后我在控制台写了几句代码希望能批量选择这一页的图标，代码如下： var elements = document.getElementsByClassName(\"icon-cover\"); for(var i = 0; i &lt; elements.length; i++){ elements[i].getElementsByTagName(\"span\")[0].click(); } 但结果是选中不了，检查了dom结构感觉自己并没有写错，无奈之下只能试试看能不能选中一个： elements[0].getElementsByTagName(\"span\")[0].click(); 上面这句代码执行后，选中了页面上的第一个图标（），奇怪的是拿elements[1]再去执行选中的话选中的第一个图标被删除了？？？我打印了elements元素之后，发现它比之前多出了一个元素 之前:之后 多出来的这个span的className也是”icon-cover”，但它的click事件是”remove(xxxx)”，也就是删除添加在购物车的图标，这个元素右侧滑块中，点击购物车可以看到这个span元素，鼠标移上去是一个删除的图标总结一下发生了什么，也就是在我选择一个图标加入购物车后，页面的dom结构发生了改变，并且这个改变也影响了改变前我们选中的元素集合，elements。因为getElementsByClassName得到的是一个HTMLCollection集合，我去MDN看了HTMLCollection，找到了这句话 HTML DOM 中的 HTMLCollection 是即时更新的（live）；当其所包含的文档结构发生改变时，它会自动更新。 这是我以前没有注意过的，赶紧记在我的小本本上= = 解决方法事情到现在我又回去看了dom结构，发现我去取document.getElementsByClassName(“icon-cover”)就是多次一举，我完全可以用document.getElementsByClassName(“icon-gouwuche1”)直接取到这个添加到购物车的span， 控制台上代码： var spans = document.getElementsByClassName(\"icon-gouwuche1\"); for(var i = 0; i &lt; .length; i++){ spans[i].click(); } 这样就解决了，成功选到了这125个图标，最开始的问题解决了我又开始想，可以取到及时更新的dom集合，但如果只想取到不更新的怎么办呢,我印象中记得querySelectorAll取到的好像是静态的集合，所以尝试了querySelectorAll方法，先用querySelectorAll选中页面中的div赋值给divs变量，再把div删除几个输出divs发现divs没有任何变化，咦，querySelectorAll不是及时更新的，那么下面这种实现也可以了： var elements = document.querySelectorAll(\"icon-cover\"); for(var i = 0; i &lt; elements.length; i++){ elements[i].querySelector(\"span\").click(); } 顺便发现了一点不同，querySelectorAll取到的是NodeList集合，去MDN看NodeList的API，有这么一句 document.querySelectorAll 返回一个静态的 NodeList, 也就意味着随后对文档对象模型的任何改动都不会影响集合的内容。 总结问题结束了，我不禁产生了疑问，HTMLCollection和NodeList有什么不同，找到一篇不错的文章，我做一下总结，方便日后复习： HTMLCollection和NodeList相同点： 都有length属性，所以都是类数组对象 都可以直接用[index]取值，或者.item(index)取值 HTMLCollection和NodeList不同点： 来源不同HTMLCollection由getElementById,getElementsByClassName等方法返回NodeList由childNodes属性，querySelectorAll方法返回 包含节点的类型不同HTMLCollection只包含html元素节点NodeList包含元素节点和其他节点，如文本节点，注释节点等 实时和有时实时HTMLCollection集合都是动态的，实时更新NodeList由childNodes属性返回时是动态的，querySelectorAll方法返回的是静态的html元素集合，即本质上是一个静态的HTMLCollection集合对象 HTMLCollection还有一个nameItem()方法，可以返回集合中name属性和id属性值的元素 结语出发点很简单但扯出了一堆东西耽误了一点时间，自己对于js基础还是掌握的不好，非常惭愧，继续学习吧，生命不息折腾不止。 参考：MDN-NodeListMDN-HTMLCollectionHTMLCollection与NodeList","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://forevehg.github.io/tags/Javascript/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"孜孜不倦,必能求索;风尘仆仆,终有归途.","slug":"孜孜不倦必能求索风尘仆仆终有归途","date":"2017-12-30T11:45:34.000Z","updated":"2025-03-17T06:05:17.784Z","comments":true,"path":"2017/12/30/孜孜不倦必能求索风尘仆仆终有归途/","link":"","permalink":"https://forevehg.github.io/2017/12/30/孜孜不倦必能求索风尘仆仆终有归途/","excerpt":"1.关于题目题目是2017年一直激励我的一句话，第一次看到是在一个技术博客的签名里，内心因为某个问题无法解决而焦躁的心也安定下来，文字真的是奇妙的东西，它安慰人于无形，如果一直在思考，一直在往前走，那么总能到达一个地方吧，哪怕那个地方没有你想象中那么的好。","text":"1.关于题目题目是2017年一直激励我的一句话，第一次看到是在一个技术博客的签名里，内心因为某个问题无法解决而焦躁的心也安定下来，文字真的是奇妙的东西，它安慰人于无形，如果一直在思考，一直在往前走，那么总能到达一个地方吧，哪怕那个地方没有你想象中那么的好。 2.关于毕业今年其实发生了很多事情，以前想起来觉得特别困难的事就在今年发生，并且都过来了。只觉得时光匆匆，我还来不及仔细的回想，这一年就到头了。年初我在北京实习，元旦假期的时候窝在群租房的床铺上搭了这个博客，然后打下了一篇总结2016年的文章发在这里，那篇文章里充满对未来的迷茫和不确定，但又有憧憬，虽然做着机械的实习工作，但回到出租屋里打开电脑学习的时候是最安心的，我是在那一段时间真的体会到学习能够让人快乐，因为学习了就有希望。在四月初我下定决心辞掉工作回到学校，那时候离毕业答辩还有一个半月的时间，我是第一批回到宿舍的，除了我之外寝室长比我早了一天，八个人的宿舍只到了两个人显得很冷清，给北方的四月也添了一点凉意。大四在学校的人很少，大家都在外忙着自己的事，毕业设计被排到微不足道的地位，报着大不了买一个的想法很少有人自己动手去做，但我想做，最后一次了，扔了上学时糊弄的那一套，就算给自己的大学时代一个交代吧。我用这样的想法激励自己，开始每天泡图书馆的生活，忙碌也充实，看着学弟学妹们散漫的样子，为他们感到惋惜，但处在那个时段的人永远不知道自己挥霍的是什么，别人点不醒，只能在经历过后才会有体会。五月初完成了毕业设计和论文，期间室友也陆陆续续的回到学校，宿舍渐渐热闹起来，早上起床可以看到对面的床铺上躺着熟悉的面孔，中午大家互相带饭，晚上熄灯后可以看到每个床铺上手机屏幕亮起的光，睡觉前互相聊上几句无关痛痒的话，平凡普通的宿舍生活，一如这四年来每一个大家一起在学校里度过的日日夜夜，可是这样的日子不多了，等待答辩的日子有些煎熬，毕业未知，工作未知，前途未知，可是我还是留恋那一段时间，过去了我就再也不是一个学生了。毕业那天其实挺平淡的，没有那些青春片里讲述的那么轰轰烈烈和充满仪式感吧，就是同级的几个班一起吃了饭，很多男生喝醉了，但是女生大都清醒，平静的回到宿舍平静的睡觉，之后有工作的匆忙的赶去工作，没有工作的又开始投入找工作的战役中，当宿舍里能卖的东西都被处理掉，四年里用过的教材也被几毛钱一斤卖掉后，我们真的要毕业了。今年冬至那天，班长在群里发消息，毕业后的第一个冬至，大家记得吃饺子，看到的这条消息的时候我正在公司忙碌，眼眶却瞬间有些湿，在学校时，每年冬至班长都会组织包饺子，今年没有了，突然觉得时光真是太快了，已经半年过去了。 2.关于第一份正式工作我找工作的一点儿经历之前写过一篇文章来记录，就不再过多去写了，总之毕业后机缘巧合就来到了现在的公司，工作上的事说太多不好，大概就是公司的主要业务不在技术这一块儿，所以工作也比较轻松，压力不大，但相对的也不太受重视，可能在技术上的成长也不快，总之在这份工作中我才真正开始迈进前端的门槛，知识多且杂，工作之余常常觉得迷茫，不知道怎么能更好的提升自己，买了很多书却没有耐心看下去，心里难免沮丧，觉得自己好像比年初时浮躁了很多，把学习抛到脑后了，可能是公司整体环境的原因吧，对自己的要求也不自觉的放松了，年底开始反省自己的状态才猛地惊觉，又重新拾起书来，每天下班要求自己静心看书，又重新体会到看书的好处，内心充实的结束这一天。 3.好像烂尾了2018年已经过去将近三个月了，这篇2017年的总结还没搞完，烂尾了….","categories":[{"name":"生活","slug":"生活","permalink":"https://forevehg.github.io/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://forevehg.github.io/tags/生活/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://forevehg.github.io/categories/生活/"}]},{"title":"前端常见面试题","slug":"前端常见面试题","date":"2017-11-07T13:09:14.000Z","updated":"2021-07-07T23:07:18.855Z","comments":true,"path":"2017/11/07/前端常见面试题/","link":"","permalink":"https://forevehg.github.io/2017/11/07/前端常见面试题/","excerpt":"1.数组扁平化//第一种方法 function flattening(array) { for (let i in array) { if (array[i] instanceof Array) { flattening(array[i]) } else { newArr.push(array[i]) } } } //第二种 array.toString().split(&#39;,&#39;)","text":"1.数组扁平化//第一种方法 function flattening(array) { for (let i in array) { if (array[i] instanceof Array) { flattening(array[i]) } else { newArr.push(array[i]) } } } //第二种 array.toString().split(',') 2.数组去重方法有很多，写几种 //第一种方法 let newArr = []; newArr.push(arr[0]); for(let i in arr){ if(newArr.indexOf(arr[i]) === -1){ newArr.push(arr[i]) } } //第二种方法 let tempArr = []; for(let i in arr){ tempArr[arr[i]] = true; } let newArr = Object.keys(tempArr); //第三种方法 let newArr = arr.filter((ele,index,array)=>{ return index === array.indexOf(ele); }) //第四种 Array.from(new Set(arr)) 3.细节3.1 toFixed42.toFixed(3) //SyntaxError .运算符会被优先识别为数字常量的一部分，42. == 42.042..toFixed(3) //正确42 .toFixed(3) //正确 3.2 较小的数值0.1+0.2 === 0.3 //false 0.1+0.2 = 0.300000000000000004 //polyfill function numbersCloseEnoughToEqual(n1,n2){ if(!Number.EPSILON){ Number.EPSILON = Math.pow(2,-52); } return Math.abs(n1-n2)&lt;Number.EPSILON; } 3.3 NaNNaN === NaN //false 4.this、作用域、闭包、对象这两个题来自掘金，原文链接 /** * Question 1 */ var name = 'window' var person1 = { name: 'person1', show1: function () { console.log(this.name) }, show2: () => console.log(this.name), show3: function () { return function () { console.log(this.name) } }, show4: function () { return () => console.log(this.name) } } var person2 = { name: 'person2' } person1.show1() person1.show1.call(person2) person1.show2() person1.show2.call(person2) person1.show3()() person1.show3().call(person2) person1.show3.call(person2)() person1.show4()() person1.show4().call(person2) person1.show4.call(person2)() 问题1答案： person1.show1() // person1 person1.show1.call(person2) // person2 person1.show2() // window person1.show2.call(person2) // window person1.show3()() // window person1.show3().call(person2) // person2 person1.show3.call(person2)() // window person1.show4()() // person1 person1.show4().call(person2) // person1 person1.show4.call(person2)() // person2 /** * Question 2 */ var name = 'window' function Person (name) { this.name = name; this.show1 = function () { console.log(this.name) } this.show2 = () => console.log(this.name) this.show3 = function () { return function () { console.log(this.name) } } this.show4 = function () { return () => console.log(this.name) } } var personA = new Person('personA') var personB = new Person('personB') personA.show1() personA.show1.call(personB) personA.show2() personA.show2.call(personB) personA.show3()() personA.show3().call(personB) personA.show3.call(personB)() personA.show4()() personA.show4().call(personB) personA.show4.call(personB)() 问题2答案： personA.show1() // personA personA.show1.call(personB) // personB personA.show2() // personA personA.show2.call(personB) // personA personA.show3()() // window personA.show3().call(personB) // personB personA.show3.call(personB)() // window personA.show4()() // personA personA.show4().call(personB) // personA personA.show4.call(personB)() // personB","categories":[{"name":"面试","slug":"面试","permalink":"https://forevehg.github.io/categories/面试/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://forevehg.github.io/tags/JavaScript/"},{"name":"面试","slug":"面试","permalink":"https://forevehg.github.io/tags/面试/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"https://forevehg.github.io/categories/面试/"}]},{"title":"js实现鼠标向上滑动显示导航栏，向下滑动隐藏导航栏.md","slug":"js实现鼠标向上滑动显示导航栏，向下滑动隐藏导航栏","date":"2017-11-07T12:53:23.000Z","updated":"2025-03-17T06:05:17.775Z","comments":true,"path":"2017/11/07/js实现鼠标向上滑动显示导航栏，向下滑动隐藏导航栏/","link":"","permalink":"https://forevehg.github.io/2017/11/07/js实现鼠标向上滑动显示导航栏，向下滑动隐藏导航栏/","excerpt":"1.引言这个效果是掘金的导航栏效果，在实现之前先来看一下实现后的样子，打开掘金后，上下滚动鼠标滚轮查看导航栏的表现。","text":"1.引言这个效果是掘金的导航栏效果，在实现之前先来看一下实现后的样子，打开掘金后，上下滚动鼠标滚轮查看导航栏的表现。 2.js滚轮事件用js实现一个导航栏随着鼠标滚轮的滚动来显示和隐藏的效果，向上滚动时显示导航栏，向下滚动时隐藏导航栏。想实现这个效果首先要了解鼠标的滚轮事件，滚轮事件的在浏览器兼容方面分为火狐和其他，火狐支持DomMouseScroll，包括ie6在内的其他浏览器支持onmousewheel: document.body.addEventListener(\"DOMMouseScroll\", function(event) { //火狐 console.dir(event); }); document.body.onmousewheel = function(event) { //其他 event = event || window.event; console.dir(event); }; 3.判断滚动方向在onmousewheel事件中，每次向上滚动event.wheelDelta的值是-120，向下滚动是120；在DOMMouseScroll事件中，每次向上滚动event.detail的值是3，向下滚动是-3，这里要注意区分。用一个例子来测试一下： var scrollfn = function(e){ e = e || window.event; if(e.wheelDelta){ if(e.wheelDelta>0){ console.log('向上滚动：',e.wheelDelta) } if(e.wheelDelta&lt;0){ console.log('向下滚动：',e.wheelDelta) } }else if(e.detail){ if(e.detail > 0){ console.log('向下滚动',e.detail) } if(e.detail &lt; 0){ console.log('向上滚动',e.detail) } } } if(document.addEventListener){ document.addEventListener('DOMMouseScroll',scrollfn,false); } window.onmousewheel = document.onmousewheel = scrollfn; 4.实现掘金导航栏的效果现在实现起来就很简单了，在上文代码的基础上进行修改，检测到滚轮向下滚动时，隐藏导航栏，检测滚轮向上滚动时，就显示导航栏，为了表现出来的效果不那么生硬，再加入动画效果，下面放上部分代码完整代码查看[具体的效果查看](https://ForeveHG.github.io/Js-Demo/juejin-nav/index.html) .nav { height: 5rem; width: 100%; background: #fff; position: fixed; top: 0; left: 0; border-bottom: 1px solid #eee; transition: all .2s; transform: translate3d(0, 0, 0); z-index: 2 } .slide_hide { transition: all .2s; transform: translate3d(0, -100%, 0); } .content_nav { width: 100%; height: 3rem; background: #fff; border-bottom: 1px solid #eee; position: fixed; top: 5rem; left: 0; transition: all .2s; transform: translate3d(0, 0, 0); } .content_nav.top { transition: all .2s; transform: translate3d(0, -5rem, 0); } var showNav = function () { if (nav) { nav.setAttribute('class', 'nav'); contentNav.setAttribute('class', 'content_nav'); } } var hideNav = function () { if (nav) { let classVal = navClassName.concat(' slide_hide'); let classContentNav = contentNavClassName.concat(' top'); nav.setAttribute('class', classVal); contentNav.setAttribute('class', classContentNav); } } var scrollFunc = function (e) { e = e || window.event; if (e.wheelDelta) { //判断浏览器IE，谷歌滑轮事件 if (e.wheelDelta > 0) { //当滑轮向上滚动时 showNav(); // console.log(\"滑轮向上滚动\",e.wheelDelta); } if (e.wheelDelta &lt; 0) { //当滑轮向下滚动时 hideNav(); // console.log(\"滑轮向下滚动\",e.wheelDelta); } } else if (e.detail) { //Firefox滑轮事件 在火狐中e.detail为负值时是向上滚动，正值是向下滚动 if (e.detail &lt; 0) { //当滑轮向上滚动时 showNav(); // console.log(\"滑轮向上滚动\",e.detail); } if (e.detail > 0) { //当滑轮向下滚动时 hideNav(); // console.log(\"滑轮向下滚动\",e.detail); } } } //给页面绑定滑轮滚动事件 if (document.addEventListener) {//firefox document.addEventListener('DOMMouseScroll', scrollFunc, false); } //滚动滑轮触发scrollFunc方法 //ie 谷歌 window.onmousewheel = document.onmousewheel = scrollFunc;","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"},{"name":"demo","slug":"技术/demo","permalink":"https://forevehg.github.io/categories/技术/demo/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://forevehg.github.io/tags/JavaScript/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"},{"name":"demo","slug":"技术/demo","permalink":"https://forevehg.github.io/categories/技术/demo/"}]},{"title":"分析zepto.js源码","slug":"分析zepto-js源码","date":"2017-10-07T08:26:29.000Z","updated":"2025-03-16T23:37:32.371Z","comments":true,"path":"2017/10/07/分析zepto-js源码/","link":"","permalink":"https://forevehg.github.io/2017/10/07/分析zepto-js源码/","excerpt":"1.zepto整体结构zepto的整体结构比较简单，就是将一个立即执行函数表达式赋值给Zepto变量，然后在全局暴露这个Zepto变量，如果$符号没有被占用，$符号也被赋值为Zepto变量，代码结构如下：","text":"1.zepto整体结构zepto的整体结构比较简单，就是将一个立即执行函数表达式赋值给Zepto变量，然后在全局暴露这个Zepto变量，如果$符号没有被占用，$符号也被赋值为Zepto变量，代码结构如下： var Zepto = (function(){ var $ $ = function(){} return $ })() window.Zepto = Zepto window.$ === undefined &amp;&amp; (window.$ = Zepto) 1.1 立即执行函数表达式(IIFE)使用立即执行函数表达，可以避免全局作用域被污染，立即执行函数表达式相当于一个容器，容器内可以访问容器外的变量，但容器外不能访问容器内的变量，这样内外不会发生冲突，相当于建立了一个私有命名空间。 2 Zepto集合对象在Zepto文档中，首先看到的就是几个核心方法,可以知道$()根据传入参数的不同分别进行了不同的处理，最后都是返回了一个zepto集合对象： $(selector, [context]) ⇒ collection $(&lt;Zepto collection>) ⇒ same collection $(&lt;DOM nodes>) ⇒ collection $(htmlString) ⇒ collection $(htmlString, attributes) ⇒ collection v1.0+ Zepto(function($){ ... }) 源码中$符号被赋值了一个函数，执行$()就相当于在执行这个函数，看一下这个函数的源码： $ = function(selector, context){ return zepto.init(selector, context) } 这个函数接收了两个参数，看意思是选择器符号和上下文，并返回了zepto.init函数的执行结果，在这里又出现了一个小写的zepto，那来找一下zepto是怎么定义的吧 zepto = {}, 在代码大概30多行的地方找到了zepto的定义，它被定义为一个空对象，那么zepto.init是它的一个属性，属性值是一个function函数，再来看一下zepto.init主要干了什么吧 zepto.init = function(selector, context) { var dom //一堆判断 return zepto.Z(dom, selector) } 这个方法对传进来的选择器字符串参数进行一系列的判断，最后返回的都是zepto.Z(xxx)的结果，看一下zepto.Z和它用到的Z这个构造函数 zepto.Z = function(dom, selector) { return new Z(dom, selector) } function Z(dom, selector) { var i, len = dom ? dom.length : 0 for (i = 0; i &lt; len; i++) this[i] = dom[i] this.length = len this.selector = selector || '' } 也就是说zepto.init最后返回的都是一个Z对象，代码到目前为止是在根据传入的参数包装dom节点，创建一个zepto集合对象，现在忽略复杂的判断，假设传入的参数都是一个css选择器，把代码简化成下面这样，引入到一个html文件中试一下 //简化的js文件 var Zepto = (function(){ var $,zepto={} function Z(dom,selector){ var i,len = dom ? dom.length : 0; for(i = 0; i&lt;len; i++) this[i] = dom[i] this.length = len this.selector = selector || '' } zepto.Z = function(dom,selector){ return new Z(dom,selector) } zepto.init = function(selector,context){ var dom = document.querySelectorAll(selector) return zepto.Z(dom,selector) } $ = function(selector,context){ return zepto.init(selector,context) } return $; })(); window.Zepto = Zepto; window.$ === undefined &amp;&amp; (window.$ = Zepto) &lt;div class=\"div1\"> &lt;div class=\"div2\">&lt;/div> &lt;/div> &lt;script src=\"zepto.js\">&lt;/script> 现在可以根据传入的css选择器选择页面上的dom元素并包装成Zepto集合对象了，但只这样接受css选择符不满足复杂的需求，所以，要对用户传入的参数进行分析，最后都要封装成Zepto对象 分析selector用户传入的selector可能有下面几种情况：1.空的，就是什么也没传进来2.字符串3.Dom元素4.Zepto元素5.其他 2. zepto内部函数2.1 compact删除数组中的null和undefined值function compact(array) { return filter.call(array, function (item) { return item != null }) } 这里用的是’!=’,undefined也会被隐式转换为null,所以可以删除掉null和undefined的值 2.2 flatten数组扁平化function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array } array的第二个参数是一个数组，它会自动将数组转换为参数列表传递给方法，参考：http://www.cnblogs.com/KeenLeung/archive/2012/11/19/2778229.htmlzepto中的flatten方法利用这一特性，将二维数组转化为一维数组 2.3 uniq数组去重 uniq = function (array) { return filter.call(array, function (item, idx) { return array.indexOf(item) == idx }) } indexOf函数得到的是元素在数组中第一次出现的位置索引值，如果当前的元素与元素第一次出现的位置不同，说明这个元素在数组中出现了多次，就将这个元素从数组中删除 2.4 数据类型判断","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://forevehg.github.io/tags/JavaScript/"},{"name":"zepto","slug":"zepto","permalink":"https://forevehg.github.io/tags/zepto/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"vue中给列表的每一项设置定时器(倒计时)","slug":"vue中给列表的每一项设置定时器-倒计时","date":"2017-08-03T06:03:38.000Z","updated":"2025-03-17T06:05:15.308Z","comments":true,"path":"2017/08/03/vue中给列表的每一项设置定时器-倒计时/","link":"","permalink":"https://forevehg.github.io/2017/08/03/vue中给列表的每一项设置定时器-倒计时/","excerpt":"目前做的项目相当于一个接任务平台，对时效性要求较高，我刚好负责任务模块，最近基本都在跟任务列表打交道，有一个需求，需要对列表中的每一项任务进行倒计时，刚开始想到的就是为每个任务都添加一个定时器来控制它的时间，","text":"目前做的项目相当于一个接任务平台，对时效性要求较高，我刚好负责任务模块，最近基本都在跟任务列表打交道，有一个需求，需要对列表中的每一项任务进行倒计时，刚开始想到的就是为每个任务都添加一个定时器来控制它的时间，但作完之后发现这简直是傻逼才会干的事儿，在一个页面上添加n个定时器，这么多定时器难以维护，而且这些定时器什么时候销毁也成了问题，况且这个项目中有任务列表的明显不止一页，每一页也不确定有多少数据，凡是跟任务挂钩的都需要定时器，如果按刚开始的思路来，后期我可能会疯掉，我不敢这么玩儿。。。于是开始想办法统一来管理定时器，我发现并不需要为每一项都添加定时器，我只需要在列表数据初始化的时候收集每一项的截止时间减去当前时间，得到每一项数据需要到倒计时的时间，把这些时间放在一个时间数组中，然后给这个页面添加一个定时器，每秒钟为这个时间数组中的每一个时间减一秒，这个时间数组在vue的data中返回，所以每次时间数组发生变化也会反映到页面上去，在跳转到其他页面的时候再销毁本页面的定时器，这是当前的一个思路，代码就不粘了，感觉思路最重要。","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://forevehg.github.io/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"vue使用时遇到的小问题及解决","slug":"vue使用时的小问题解决","date":"2017-07-20T13:30:15.000Z","updated":"2025-03-17T06:05:06.988Z","comments":true,"path":"2017/07/20/vue使用时的小问题解决/","link":"","permalink":"https://forevehg.github.io/2017/07/20/vue使用时的小问题解决/","excerpt":"现在已经是2018年的1月20号了，从2017年7月20号左右开始用vue做东西，差不多半年的时间做了两个项目，一个移动端，一个PC端，第一个项目真的是文档大概浏览一下就直接上手干了，刚开始感觉有点儿艰难，不过熟悉之后觉得vue的开发体验简直太棒了，","text":"现在已经是2018年的1月20号了，从2017年7月20号左右开始用vue做东西，差不多半年的时间做了两个项目，一个移动端，一个PC端，第一个项目真的是文档大概浏览一下就直接上手干了，刚开始感觉有点儿艰难，不过熟悉之后觉得vue的开发体验简直太棒了，所以第二个项目也果断选择了vue开发，现在项目第一个阶段已经初步完成马上测试了，感觉选择vue真是太对了，虽然也遇到很多问题，但整体开发过程都很顺畅。从这篇文章也可以看出从最开始的小白一点儿点儿学习进步吧，这些问题在发生的时候都是真真实实的给我造成了一些问题，所以解决后选择记录下来，但现在回过头来看发现其实这些都是很小的一些问题，有粗心造成，有因为对vue-cli一知半解闹的笑话，有在提交代码时跟团队另一个前端代码冲突发生的一些小问题，有使用各种组件时遇见的坑，还有在业务场景中遇见的一些小需求的解决过程，半年里所有的这些都是自己去学习尝试去解决，公司里没有前端这方面的人可以带带我，所以也是自己在琢磨，希望新的一年不仅要知道如何使用vue，更要去学习vue的原理是什么，只要还在用vue，这篇文章就会一直更新下去，加油吧我自己。 —2018.1.20有感 最近的在使用vue做东西，初次使用遇见很多问题，把这些小问题记录下来，希望给遇到同样问题的同学一个参考，也便于自己以后查阅，持续更新中。 1.vue-cli构建的项目端口冲突报错：Error: listen EADDRINUSE :::8080 错误原因是端口冲突，修改当前项目的端口即可，在项目下的config/index.js文件中修改 dev: { env: require('./dev.env'), port: 8081, //修改端口号 autoOpenBrowser: true, assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: {}, cssSourceMap: false } 2.解决在vue-cli构建的项目中无法使用stylus的问题报错：Module build failed: Error: Cannot find module ‘stylus’解决： 2.1 首先在package.json的devDependencies中写入依赖\"stylus-loader\": \"^2.1.2\", \"stylus\": \"^0.52.4\", 2.2 安装这两个插件npm i stylus-loader stylus --save 或者直接在项目文件夹下 npm install 2.3 重新编译运行npm run dev 3.运行后一片空白，chrome控制台报错报错：Uncaught TypeError: WEBPACK_IMPORTED_MODULE_2router__.a is not a constructor描述：在使用vue-router时出现了这个问题,在网上搜索后发现是版本不同导致的问题，在vue2.x中使用了1.0的vue-router的写法，在vue1.0中: 商品修改为vue2.0中的写法: 商品 4.配置默认路径没有进行配置时，引用组件只能通过下面的方式 import Goods from ‘../components/goods/goods’;并且’../‘写多了也很烦人，如果不加’../‘会报一下错误：报错：Module not found: Error: Can’t resolve ‘components/goods/goods’ in ‘F:\\vuetest\\vue-project\\src\\router’为此我们可以配置默认路径来解决这个问题。1.找到build文件夹下的webpack.base.conf.js文件2.在文件中找到这一段代码: resolve: { extensions: ['.js', '.vue', '.json'], alias: { 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src') } } alias是别名的意思，我们可以为常用的路径起一个别名,如下面这样 resolve: { extensions: ['.js', '.vue', '.json'], alias: { 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), 'components': path.resolve(__dirname, '../src/components') } }, 在修改完成后要重新运行，才能生效，现在页面中的import Goods from &#39;components/goods/goods&#39;;应该就可以了。 补充：这样配置的路径只在script标签中有效，也就是只能在js中用。 5.使用v-for在获取computed中的值时出现的问题报错：xxx is not defined on the instance but referenced during render.Make sure to declare reactive data properties in the data option.这个问题犯得很不应该，错把computed属性写在了props属性中，导致vue找不到computed中定义的计算函数，是个低级错误，不多说了。 6.在vue中实现左右滑动切换watch路由变化，当路由发生改变时，根据地址中’/‘的数量来判断当前路由地址的深浅，以此决定要左滑还是右滑 export default { name: 'app', data(){ return { transitionName :'slide-left', //绑定在组件上面的动效class } }, watch: { '$route' (to, from){ const toDepth = to.path.split('/').length const fromDepth = from.path.split('/').length this.transitionName = toDepth &lt; fromDepth ? 'vux-pop-out' : 'vux-pop-in' } } } &lt;style lang=\"stylus\" rel=\"stylesheet/stylus\"> /* 左右滑动 */ .vux-pop-out-enter-active, .vux-pop-out-leave-active, .vux-pop-in-enter-active, .vux-pop-in-leave-active will-change: transform transition: all 350ms height: 100% top: 0 position: absolute backface-visibility: hidden perspective: 1000 .vux-pop-out-enter opacity: 0 transform: translate3d(-100%, 0, 0); .vux-pop-out-leave-active opacity: 0 transform: translate3d(100%, 0, 0); transform-style: preserve-3d; .vux-pop-in-enter opacity: 0 transform: translate3d(100%, 0, 0); transform-style: preserve-3d; .vux-pop-in-leave-active opacity: 0 transform: translate3d(-100%, 0, 0); transform-style: preserve-3d; &lt;/style> 7.在keep-alive中只更新某个组件的数据我有一个列表，点击列表的项可以打开详情页，在我没有使用keep-alive时，一切正常，我点击某一项，详情页中显示的是当前项的数据，不过在使用keep-alive进行组件缓存后就出事了，我不管点击哪一项总是会打开第一次缓存的详情组件，数据也不会改变，我是通过vue-router传参到详情页面的: taskDetail: function(item){ this.$router.push({path:'/task/detail',query:{item:item}}); } 查看官方文档，发现下面这段话： 在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 树内的所有嵌套组件中触发。 那么我只要每次在activated中做数据更新就行了，如下： activated(){ this.item = this.$route.query.item; } 8.使用better-scroll时列表不滚动的问题有必要先了解一下better-scroll的原理,下面的链接中讲的非常清楚：better-scroll也就是说滚动列表的父元素要有一个固定的高度，只有这样滚动列表的高度超过父元素的高度是列表才会滚动，不超过时就不滚动，总之在better-scroll的引入和写法没错的情况下还不能滚动，那大多数原因就是css的样式没写对，导致不符合better-scroll滚动的条件，那来看一个非常简单的例子吧,主要是css部分： &lt;template> &lt;div class=\"parent\"> &lt;div class=\"child_div\" ref=\"wrapper\"> &lt;ul> &lt;li>1&lt;/li> &lt;li>2&lt;/li> ... &lt;li>299&lt;/li> &lt;li>300&lt;/li> &lt;/ul> &lt;/div> &lt;/div> &lt;/template> &lt;script type=\"text/ecmascritp-6\"> import BScroll from 'better-scroll' export default { created () { this.$nextTick(function () { this.scroll = new BScroll(this.$refs.wrapper, {}) }) } } &lt;/script> &lt;style scoped> .parent{ position: absolute; top: 0; bottom: 0; width: 100%; } .child_div{ position: relative; height: 100%; overflow: hidden; } .child_div li{ height:20vw; } &lt;/style> 9.better-scroll中警告[Intervention] Unable to preventDefault inside passive event listener due to target being treated as passive这个警告信息是因为在新版的chrome中监听touch类事件时，无法被动侦听事件preventDefault造成的，在better-scroll中暂时解决的方法是在初始化better-scroll时设置preventDefault: false this.scroll = new BScroll(this.$refs.wrapper, { preventDefault: false, //暂时解决chrome中无法被动监听preventdefault }); 10.只在一级菜单显示底部导航在网上搜索之后发现两种方法可以解决，先说第一种：在router文件夹下的index.js中将需要显示底部导航的路由中加入meta属性,在meta属性中添加一个标志属性，用来标志是否显示底部导航，这里我们用navShow来做为标志属性，如下所示： { path: '/home', component: home, /*主页组件*/ meta: { title: '首页', navShow: true,/*是否一级页面*/ }, } 不需要显示底部导航的设置为下面这样： { path: '/login', meta: { title: '登陆', navShow: false,/*是否一级页面*/ }, component: login /*登录组件*/ } 然后，在APP.vue中，底部导航的组件上加上判断,就完成了 &lt;vTab v-show=\"$route.meta.navShow\">&lt;/vTab> 第二种方法比较笨，在你不希望底部导航显示的组件中，直接设置css样式，让它盖在底部导航上，用户就看不到了，比如可以设置z-index属性为一个较大值。 11.本地跨域由于刚开始工作，没有什么经验，又是刚开始接触vue，虽然网上有很多文章介绍vue本地跨域，但是还是一知半解，设置了也没有成功，在纠结了好大一通后终于成了，发现哦原来这么简单，但是不明白时却觉得很难， 12.去掉路由中的#号路由中总是会带有一个#号，如http://192.168.0.144:8098/#/index看起来很别扭， 要去除这个#号，可以使用路由的history模式，在router/index.js中的new VueRouter方法中添加： var Routes = new VueRouter({ mode: 'history', routes: [...] }) 这样路由就会变成http://192.168.0.144:8098/index 13.iview中的upload组件上传图片到七牛云项目中用到iview中的upload组件将图片上传到七牛云，比较简单，主要是uptoken在测试阶段后台没有弄好，一时不知道在哪儿搞，后来发现可以在线生成uptoken，在线地址，下面写一下示例，具体的组件 &lt;Upload :action=\"url\"> &lt;div> &lt;Icon type=\"camera\" size=\"30\">&lt;/Icon>&lt;/div> &lt;/Upload> data:function(){ return{ domain: config.domain, //如下图中被马赛克掉的内容 url: config.qiniuUrl, //http://up-z2.qiniu.com/ uptoken: '', //生成或者从后台拿到uptoken form: { token: '', key: null }, } } domain 14.vue中图片路径问题以下两种情况会导致找不到图片路径的问题： 1. ``` &lt;img :src=&quot;./img/a.jpg&quot; /&gt;&quot; ``` 2. ``` &lt;div :style=&quot;{ backgroundImage: &#39;url(./img/a.jpg)&#39; }&quot;&gt;&lt;/div&gt; ``` 可以使用下面的两种方法解决： data () { return { img: require('path/to/your/source') } } 在标签里使用： &lt;img :src=\"img\" /> ` 如果是背景： data () { return { img: require('path/to/your/source') } } &lt;div :style=\"{backgroundImage: 'url(' + img + ')'}\">&lt;/div> 15.图片加载失败时显示默认图片在使用img标签时，当图片加载失败的时候显示默认图片，这样的用户体验比较友好。方法是绑定img标签的onerror，在图片加载失败时就会自动加载errorImg01的图片 &lt;div class=\"bg\"> &lt;img :src=\"goods.phoneFloorAd.resUrl\" :onerror=\"errorImg01\"> &lt;/div> &lt;script type=\"text/ecmascript-6\"> export default { data () { return { errorImg01: ‘this.src=\"‘ + require(‘assets/images/load_logo01.png‘) + ‘\"‘ }; } } &lt;/script> 第二种情况是设置的背景图片加载失败时显示默认图片，方法是可以利用计算属性获取背景图片，图片获取成功时正常显示，获取失败时显示默认图片，代码如下： 16. vue-cli打包时报错错误代码：vuex requires a Promise polyfill in this browser.这个错误的原因是使用了es6的promise，但是ie版本(使用ie11)的浏览器不支持，解决的方法是安装 babel-polyfill ， babel-polyfill 可以模拟es6的使用环境 1.安装 babel-polyfillnpm install babel-polyfill 2.修改webpack.base.config.jsmodule.exports = { entry: { main: [\"babel-polyfill\", \"./src/main\"], //修改后 // main: './src/main', //原来 vendors: './src/vendors' } } 参考https://www.cnblogs.com/weiqinl/p/6794612.html 17. vue-cli打包时报错运行npm run dev时没有问题，但运行npm run build时报错 Error: \"extract-text-webpack-plugin\" loader is used without the corresponding plugin 是在我把vue-cli升级到@2.9.2之后出现的问题，没有找到原因，删除又安装了@2.8.2后可以打包了 18.vscode格式化vue中template代码1.安装 vetur2.在User Setting中增加设置:&quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot; 3.格式化快捷键：Alt+Shift+F19.vue中通过a标签下载文件想不通过后台直接下载一个excel文件，我用了&lt;a href=&quot;/file/filename&quot; download=&quot;filename&quot;&gt;但是提示我找不到文件，想到img标签的src属性，是要把文件通过require引入，再通过url-loader解析一下，才能正常显示图片，所以想这个href属性是不是同样的套路，那excel文件用什么解析呢，搜索之后发现有一个file-loader，所以在webpack的配置文件里加上了下面的几行配置 { test: /\\.(xls)$/, loader: 'file-loader', } 在代码中只需要把这个文件require进来，在href中写上这个变量就可以了，跟img一样 &lt;a :href=\"fileHref\" download=\"fileName\">&lt;/a> data:function(){ return{ fileHref: require(\"/file/filename\") } } 待续吧…","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://forevehg.github.io/tags/vue/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"项目中小知识点的积累","slug":"项目中小知识点的积累","date":"2017-07-15T14:30:15.000Z","updated":"2020-05-17T15:11:45.000Z","comments":true,"path":"2017/07/15/项目中小知识点的积累/","link":"","permalink":"https://forevehg.github.io/2017/07/15/项目中小知识点的积累/","excerpt":"这一篇用来记录一下项目中遇见的小问题，以及解决方法","text":"这一篇用来记录一下项目中遇见的小问题，以及解决方法 1.多行文字的垂直居中2.jQuery+Ajax结果用prepend实现淡入及滑动效果AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。由于其可以减少服务器请求并能提升用户体验，现在很多地方都在用。这两天做一个Ajax评论的时候，用 prepend() 方法把结果直接插入到页面上，虽然可以实现功能，但是页面直接多出这么一块东西，效果不是很好，所以就想用 fadeIn() 方法或 slideDown() 方法来把结果展现出来，但是发现直接在 prepend() 方法后接上 fadeIn() 并不管用。后来发现在调用 prepend() 方法的时候，结果其实本身已经是显示状态了，所以 fadeIn() 方法起不到作用。解决办法是在 prepend() 之前让结果先隐藏，即加上一个 hide() 方法。 var response = '&lt;li class=\"list-group-item\">This is a additional line !&lt;/li>'; $('.b1').click(function(){ $(response).hide().prependTo($('.list-group')).fadeIn('slow'); //或者 $('.list-group').prepend($(response).hide().fadeIn('slow')); }) 4.七牛云uptoken在线生成器在线uptoken生成 5.支持中文的base64转码和解码//转码 function base64Encode(input){ var rv; rv = encodeURIComponent(input); rv = unescape(rv); rv = window.btoa(rv); return rv; } //解码 function base64Decode(input){ rv = window.atob(input); rv = escape(rv); rv = decodeURIComponent(rv); return rv; } 6.在线加密解密在线加密解密 7.手机上访问pc端编写的页面服务器用的是Apache,先开启服务器，将项目文件夹放在服务器指定的文件夹下，这是在电脑上可以通过http://localhost/文件目录 来访问，手机想要访问的话要与pc在同一个局域网，同时查到pc端的ip地址，将localhost改为ip地址，即可在手机上访问。这次遇到一个问题，在pc端可以成功访问，但是放在手机上就报403 forbidden拒绝访问的错误，经过查找，发现httpd.conf文件中的配置有问题，当前的配置如图,几个配置的含义：Require local 仅允许本地访问；Require all denied 拒绝所有访问；Require all granted 允许所有访问；Require ip 192.168.0.1 仅允许IP：192.168.0.1 访问；Require not ip 192.168.0.1 仅禁止IP：192.168.0.1访问；所以我们应该修改成Require all granted 允许所有访问，修改后如下图：参考http://www.cnblogs.com/chayu/p/6889793.html非常感谢","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://forevehg.github.io/tags/总结/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"从头学习HTMl5(一)","slug":"从头学习HTMl5-一","date":"2017-06-04T09:54:59.000Z","updated":"2020-05-17T15:11:16.000Z","comments":true,"path":"2017/06/04/从头学习HTMl5-一/","link":"","permalink":"https://forevehg.github.io/2017/06/04/从头学习HTMl5-一/","excerpt":"1.注释标签 注释标签除了在代码中添加注释的功能外，还可以在不支持js的浏览器中隐藏js代码：","text":"1.注释标签 注释标签除了在代码中添加注释的功能外，还可以在不支持js的浏览器中隐藏js代码： &lt;script type=\"text/javascript\"> &lt;!-- alert(\"支持JavaScript\") //--> &lt;/script> 在不支持js的浏览器中，最后的//–&gt;不会被当成注释，注释标签可以成功闭合，js代码就不会执行；在支持js的浏览器中//后面的内容被解析为js注释，没有闭合，中间的js代码可以执行。 2.html5中新增的结构标签article、aside、","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://forevehg.github.io/tags/HTML5/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"Git提交文件到GitHub时出现的问题记录","slug":"Git提交文件到GitHub时出现的一些问题","date":"2017-05-19T00:13:45.000Z","updated":"2025-03-17T06:05:17.784Z","comments":true,"path":"2017/05/19/Git提交文件到GitHub时出现的一些问题/","link":"","permalink":"https://forevehg.github.io/2017/05/19/Git提交文件到GitHub时出现的一些问题/","excerpt":"1.输入命令$ git push origin master时，出现Everything up-to-date我是在提交项目中新创建的文件时出现这个问题，是因为没有对新创建的文件执行","text":"1.输入命令$ git push origin master时，出现Everything up-to-date我是在提交项目中新创建的文件时出现这个问题，是因为没有对新创建的文件执行 git add 新文件 git commit -m '提交描述信息' 这两个命令执行成功后再去执行 git push origin master 现在应该就没有问题了 2.Untracked files git commit -m '内容提交' On branch master Your branch is up-to-date with 'origin/master'. Untracked files: .gitignore .tmp/ .watchmanconfig JsCode/ Test/ __tests__/ android/ app.json index.android.js index.ios.js ios/ package.json setup.js yarn.lock nothing added to commit but untracked files present 3.Your local changes to the following files would be overwritten by mergegit stashgit pullgit stash pop 4 error: Pulling is not possible because you have unmerged files1.pull会使用git merge导致冲突，需要将冲突的文件resolve掉 git add -u, git commit之后才能成功pull. 2.如果想放弃本地的文件修改，可以使用git reset –hard FETCH_HEAD，FETCH_HEAD表示上一次成功git pull之后形成的commit点。然后git pull.注意： git merge会形成MERGE-HEAD(FETCH-HEAD) 。git push会形成HEAD这样的引用。HEAD代表本地最近成功push后形成的引用。 5.git push时报错The requested URL returned error: 403起因是在网上下载了后台代码，经过修改后想上传到github，git push时报错The requested URL returned error: 403，原因是这个代码中的.git文件夹是原代码的项目github仓库，这个网址我是提交不上的，那么，就要把原来的github地址改成自己的地址，修改 config 文件，找到 [remote “origin”] 节点下的 url 项，将这个url地址改为自己的github仓库地址，另一种方法是直接把项目中的.git文件夹删掉，再执行git init，然后进行提交。 6.github Host key verification failed主机密钥验证失败，其实这是缺少了 known_hosts 文件, 而且必须生成 github.com 的ip执行内容。输入：ssh git@github.com回车后出现下图的内容，输入yes，这时再提交，就没事了 7. git pull报错：error: Your local changes to ‘c/environ.c’ would be overwritten by merge. Aborting.在使用git pull代码时，经常会碰到有冲突的情况，提示如下信息：error: Your local changes to ‘c/environ.c’ would be overwritten by merge. Aborting.Please, commit your changes or stash them before you can merge.这个意思是说更新下来的内容和本地修改的内容有冲突，先提交你的改变或者先将本地修改暂时存储起来。处理的方式非常简单，主要是使用git stash命令进行处理，分成以下几个步骤进行处理。 1、先将本地修改存储起来$ git stash这样本地的所有修改就都被暂时存储起来 。这时用git stash list可以看到保存的信息：git stash暂存修改其中stash@{0}就是刚才保存的标记。 2、pull内容暂存了本地修改之后，就可以pull了。$ git pull 3、还原暂存的内容$ git stash pop stash@{0}系统提示如下类似的信息： Auto-merging c/environ.c CONFLICT (content): Merge conflict in c/environ.c 意思就是系统自动合并修改的内容，但是其中有冲突，需要解决其中的冲突。 4、解决文件中冲突的的部分打开冲突的文件，会看到类似如下的内容：git冲突内容其中Updated upstream 和=====之间的内容就是pull下来的内容，====和stashed changes之间的内容就是本地修改的内容。碰到这种情况，git也不知道哪行内容是需要的，所以要自行确定需要的内容。解决完成之后，就可以正常的提交了。 5. 回复到merge前第一步：git checkout到你要恢复的那个分支上 git checkout 分支名 第二步：git reflog查出要回退到merge前的版本号 git reflog 第三步：git reset --hard [版本号]就回退到merge前的代码状态了 git reset --hard f82cfd2","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://forevehg.github.io/tags/Git/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"常用JS代码片段","slug":"常用JS代码片段","date":"2017-05-17T00:39:45.000Z","updated":"2025-03-17T06:05:17.808Z","comments":true,"path":"2017/05/17/常用JS代码片段/","link":"","permalink":"https://forevehg.github.io/2017/05/17/常用JS代码片段/","excerpt":"1.隐藏部分数字，如手机号码，身份证号码function mask(str,start,length,mask_char){ return str.replace(str.substr(start,length),Array(length+1).join(mask_char||&quot;*&quot;)) }","text":"1.隐藏部分数字，如手机号码，身份证号码function mask(str,start,length,mask_char){ return str.replace(str.substr(start,length),Array(length+1).join(mask_char||\"*\")) } 2.获取指定范围内的随机数function randNum(minnum,maxnum){ return Math.floor(minnum+Math.random()*(maxnum-minnum)); } randNum(0,10)得到的是0到9之间的随机数 3.全选，全不选&lt;div> &lt;input type=\"checkbox\" id=\"checkAll\"/>全选 &lt;input type=\"checkbox\"/>吃饭 &lt;input type=\"checkbox\"/>睡觉 &lt;input type=\"checkbox\"/>打豆豆 &lt;/div> var checkAll = document.getElementById('checkAll'); var checkBoxs = document.getElementsByTagName('input'); var select = false; checkAll.addEventListener('click',function(){ select = !select; for(let i in checkBoxs){ checkBoxs[i].checked = select; } },false) 4.js原生判断元素是否隐藏当容器元素的style.display 被设置为 “none”时（IE和Opera除外），offsetParent属性返回 null。 var isHidden = function (element) { return (element.offsetParent === null); }; 5.jquery中判断对象是否为空对象空对象{}肯定是没有属性的，所以通过遍历他的属性来判断它是否是空对象 function isEmptyObject(e) { var t; for (t in e) return !1; return !0 } 5.数组去重判断当前元素的位置是否是该元素第一次出现的位置，如果不是说明元素重复。indexOf是查找元素第一次出现位置的索引值 function uniq(array){ return Array.prototype.filter.call(array,function(item,idx){ return array.indexOf(item) == idx; }) }","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://forevehg.github.io/tags/JavaScript/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"在React-Native项目中引入react-native-sqlite-storage","slug":"在React Native项目中引入react-native-sqlite-storage","date":"2017-03-30T13:42:18.000Z","updated":"2020-05-17T15:11:47.000Z","comments":true,"path":"2017/03/30/在React Native项目中引入react-native-sqlite-storage/","link":"","permalink":"https://forevehg.github.io/2017/03/30/在React Native项目中引入react-native-sqlite-storage/","excerpt":"前言最近在使用React Native做毕业设计，因为第一次接触踩了不少坑，不过好在都解决了，这篇主要记录一下在React-Native中引入’react-native-sqlite-storage’的方法：","text":"前言最近在使用React Native做毕业设计，因为第一次接触踩了不少坑，不过好在都解决了，这篇主要记录一下在React-Native中引入’react-native-sqlite-storage’的方法：目前在react-native中主要有两种数据存储方案，第一种是官方的AsyncStorage，AsyncStorage是一个简单的、异步的、持久化的Key-Value存储系统，它对于App来说是全局性的它适用于存储些系统设置、全局变量等简单的key-value数据，不适用于过于庞大的数据，也不适用于一些包含数据结构等复杂数据，对于复杂的数据结构，我们需要使用SQLite，轻量的数据库，但RN并没有提供，不过有这种需求的肯定不止我一个，所以现在拿来直接使用，我在这里用的是react-native-sqlite-storage。且由于没有ios设备，这里只说安卓平台。 1. 命令行安装npm install --save react-native-sqlite-storage 2. 全局Gradle的设置文件目录：android/settings.gradle ... include &#39;:react-native-sqlite-storage&#39; project(&#39;:react-native-sqlite-storage&#39;).projectDir = new File(rootProject.projectDir, &#39;../node_modules/react-native-sqlite-storage/src/android&#39;) 3. 修改android/app/build.gradle目录：android/app/build.gradle ... dependencies { ... compile project(&#39;:react-native-sqlite-storage&#39;) } 4. 在MainActivity.java中注册模块目录：android\\app\\src\\main\\java\\com\\项目名\\MainActivity.java import android.app.Activity; import android.os.Bundle; import com.facebook.react.modules.core.DefaultHardwareBackBtnHandler; import com.facebook.react.ReactInstanceManager; import com.facebook.react.ReactRootView; import com.facebook.react.shell.MainReactPackage; import com.facebook.react.common.LifecycleState; import com.facebook.react.ReactActivity; import org.pgsqlite.SQLitePluginPackage; public class MainActivity extends Activity implements DefaultHardwareBackBtnHandler { private ReactInstanceManager mReactInstanceManager; private ReactRootView mReactRootView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mReactRootView = new ReactRootView(this); mReactInstanceManager = ReactInstanceManager.builder() .setApplication(getApplication()) .setBundleAssetName(&quot;index.android.bundle&quot;) // this is dependant on how you name you JS files, example assumes index.android.js .setJSMainModuleName(&quot;index.android&quot;) // this is dependant on how you name you JS files, example assumes index.android.js .addPackage(new MainReactPackage()) .addPackage(new SQLitePluginPackage(this)) // register SQLite Plugin here .setUseDeveloperSupport(BuildConfig.DEBUG) .setInitialLifecycleState(LifecycleState.RESUMED) .build(); mReactRootView.startReactApplication(mReactInstanceManager, &quot;AwesomeProject&quot;, null); //这里把AwesomeProject setContentView(mReactRootView); } @Override public void invokeDefaultOnBackPressed() { super.onBackPressed(); } } 5. 引入这样应该就引入成功了，具体的使用还在学习，后续再补充上来。 6. 坑今天跑起来后发现出事儿了，开发者菜单调不出来了，而且我用来测试的alert语句会发出一个警告，如图：在网上没有找到同样的问题，但是sqlite能工作，而且只发出警告有感觉是因为版本的问题，试着将配置方式改了一下，结果就成了。将MainActivity.java中添加和修改的内容都删除了，还原到原来的内容： package com.项目名; import com.facebook.react.ReactActivity; public class MainActivity extends ReactActivity { /** * Returns the name of the main component registered from JavaScript. * This is used to schedule rendering of the component. */ @Override protected String getMainComponentName() { return &quot;项目名&quot;; } } MainApplication文件中的内容： package com.weidao; import android.app.Application; import android.util.Log; import com.facebook.react.ReactApplication; import com.facebook.react.ReactNativeHost; import com.facebook.react.ReactPackage; import com.facebook.react.shell.MainReactPackage; import com.facebook.soloader.SoLoader; import org.pgsqlite.SQLitePluginPackage; import java.util.Arrays; import java.util.List; public class MainApplication extends Application implements ReactApplication { private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) { @Override public boolean getUseDeveloperSupport() { return BuildConfig.DEBUG; } @Override protected List&lt;ReactPackage&gt; getPackages() { return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new SQLitePluginPackage() ); } }; @Override public ReactNativeHost getReactNativeHost() { return mReactNativeHost; } @Override public void onCreate() { super.onCreate(); SoLoader.init(this, /* native exopackage */ false); } } 其他没变，这样终于可以了&gt;_&lt;_","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://forevehg.github.io/tags/React-Native/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"React Native控件的使用之ListView","slug":"React Native中的ListView和ScrollView控件","date":"2017-03-18T12:28:05.000Z","updated":"2020-05-17T15:12:34.000Z","comments":true,"path":"2017/03/18/React Native中的ListView和ScrollView控件/","link":"","permalink":"https://forevehg.github.io/2017/03/18/React Native中的ListView和ScrollView控件/","excerpt":"1.ListView控件 功能：用于显示一个可垂直滚动的变化的数据列表。下面用一个简单的例子来展示一下ListView的用法","text":"1.ListView控件 功能：用于显示一个可垂直滚动的变化的数据列表。下面用一个简单的例子来展示一下ListView的用法 1.1 案例效果 1.2 案例代码//定义原始数据：数组（字符串） //假装一数组的男神都是我的&gt;_&lt; var contents =[ &#39;1. 韩庚&#39;, &#39;2. 韩庚&#39;, &#39;3. 韩庚&#39;, &#39;4. 韩庚&#39;, &#39;5. 韩庚&#39;, &#39;6. 韩庚&#39;, &#39;7. 韩庚&#39;, &#39;8. 韩庚&#39;, &#39;9. 韩庚&#39;, &#39;10. 韩庚&#39;, &#39;11. 韩庚&#39;, &#39;12. 韩庚&#39;, &#39;13. 韩庚&#39; ]; //ListViewTest1 export default class ListViewTest1 extends Component{ constructor(props){ super(props); //创建一个ListView.DataSource数据源，然后给它传递一个普通的数据数组 let ds = new ListView.DataSource({ //通过判断决定渲染哪些行组件，避免全部渲染，提高渲染效率 rowHasChanged: (oldRow, newRow) =&gt; oldRow != newRow }); this.state = { //在dataSource中，不直接使用提供的原始数据 //使用cloneWithRows方法对数据源进行复制， //使用复制后的数据源实例化ListView //好处：当原始数据发生变化时，ListView的dataSource不会改变 dataSource: ds.cloneWithRows(contents) } } //渲染row的方法，参数是每行显示的数据对象 _renderRow(rowData:string){ return ( &lt;View style={styles.row}&gt; &lt;Text style={styles.content}&gt;{rowData}&lt;/Text&gt; &lt;/View&gt; ) } render(){ return ( &lt;ListView style={styles.container} //设置数据源 dataSource={this.state.dataSource} //配置每一行的组件 renderRow={this._renderRow} /&gt; ) } } const styles = StyleSheet.create({ container:{ flex:1, marginTop:25 }, row:{ justifyContent:&#39;center&#39;, alignItems:&#39;center&#39;, padding:25, borderBottomWidth:1, borderColor:&quot;#ccc&quot;, }, content:{ flex:1, fontSize:20, color:&#39;blue&#39; } }); 2.ScrollView控件2.1 案例演示2.2 案例代码import React ,{Component} from &#39;react&#39;; import{ View, Text, RefreshControl, StyleSheet, ScrollView, TouchableWithoutFeedback }from &#39;react-native&#39;; class Row extends Component{ _onClick(){ this.props.onClick(this.props.data) }; render(){ return ( &lt;TouchableWithoutFeedback style={{backgroundColor:'red'}} onPress={this._onClick.bind(this)} &gt; &lt;View style={styles.row}&gt; &lt;Text&gt; {this.props.data.text+&#39; 已收到&#39;+this.props.data.clicks+&#39;颗心&#39;} &lt;/Text&gt; &lt;/View&gt; &lt;/TouchableWithoutFeedback&gt; ) } } export default class RefreshControlTest extends Component{ constructor(props){ super(props); this.state={ isRefreshing:false, rowData:Array.from(new Array(20)).map( (val,i)=&gt;({text:&#39;韩庚韩庚我爱韩庚&#39;+i,clicks:0}) ) } }; _onClick(row){ row.clicks++; this.setState({ rowData: this.state.rowData, }); }; render(){ const rows = this.state.rowData.map( (row,ii)=&gt;{ return (&lt;Row key={ii} data={row} onClick={this._onClick.bind(this)} /&gt;) } ); return( &lt;ScrollView style={styles.containers} refreshControl={ &lt;RefreshControl refreshing={this.state.isRefreshing} onRefresh={this._onRefresh.bind(this)} colors={[&#39;#FFB3B3&#39;]} progressBackgroundColor=&quot;#fff&quot; /&gt; } &gt; {rows} &lt;/ScrollView&gt; ); } _onRefresh(){ this.setState({isRefreshing:true}); setTimeout(()=&gt;{ const rowData = this.state.rowData.map((item,i)=&gt;( {text:&#39;送你我的小心心 点击送心：&#39;,clicks:0} )); this.setState({ isRefreshing:false, rowData:rowData }) },2000) } } const styles = StyleSheet.create({ containers:{ flex:1, backgroundColor:&quot;#eee&quot; }, row:{ flex:1, padding:25, borderWidth:1, borderColor:&#39;#000&#39; } });","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://forevehg.github.io/tags/React-Native/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"使用React实现的Todo List Demo","slug":"使用React实现的Todo-Demo","date":"2017-03-17T14:18:38.000Z","updated":"2025-03-17T05:55:02.233Z","comments":true,"path":"2017/03/17/使用React实现的Todo-Demo/","link":"","permalink":"https://forevehg.github.io/2017/03/17/使用React实现的Todo-Demo/","excerpt":"","text":"1.demo预览实现后的效果在线查看github地址","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"React","slug":"React","permalink":"https://forevehg.github.io/tags/React/"},{"name":"Demo","slug":"Demo","permalink":"https://forevehg.github.io/tags/Demo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"React Native学习过程中的资料收集","slug":"React Native学习过程中的资料收集","date":"2017-02-24T13:08:34.000Z","updated":"2020-05-17T15:12:26.000Z","comments":true,"path":"2017/02/24/React Native学习过程中的资料收集/","link":"","permalink":"https://forevehg.github.io/2017/02/24/React Native学习过程中的资料收集/","excerpt":"1.中文文档和相关技术博客1.React-Native中文文档2.江青清的技术专栏-React Native技术文章","text":"1.中文文档和相关技术博客1.React-Native中文文档2.江青清的技术专栏-React Native技术文章2.React-Native-学习资源精选仓库3.React-Native之React速学教程-(上)/)React-Native之React速学教程-(中)/)React-Native之React速学教程-(下)/) 2.视频1.React Native零基础入门到项目实战-CSDN学院视频 3.组件1.新手理解navigator的教程2.react native组件学习之listview3.react-native-scrollable-tab-view(入门篇)4.react-native-scrollable-tab-view(进阶篇) 4.实战1.React Native实现一个看韩剧App 5.开源项目1.慕课网全栈项目:小明找厕所","categories":[{"name":"资料","slug":"资料","permalink":"https://forevehg.github.io/categories/资料/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"https://forevehg.github.io/tags/React-Native/"}],"keywords":[{"name":"资料","slug":"资料","permalink":"https://forevehg.github.io/categories/资料/"}]},{"title":"MVC,MVP,MVVM的区别","slug":"MVC-MVP-MVVM","date":"2017-02-03T12:59:28.000Z","updated":"2020-05-17T15:11:57.000Z","comments":true,"path":"2017/02/03/MVC-MVP-MVVM/","link":"","permalink":"https://forevehg.github.io/2017/02/03/MVC-MVP-MVVM/","excerpt":"复杂的软件必须有清晰合理的架构，否则无法开发和维护。 MVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解，但是要讲清楚，它与衍生的 MVP 和 MVVM 架构的区别就不容易了。","text":"复杂的软件必须有清晰合理的架构，否则无法开发和维护。 MVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解，但是要讲清楚，它与衍生的 MVP 和 MVVM 架构的区别就不容易了。 一、MVCMVC模式的意思是，软件可以分成三个部分。 视图（View）：用户界面。 控制器（Controller）：业务逻辑 模型（Model）：数据保存 各部分之间的通信方式如下。 View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 所有通信都是单向的。 二、互动模式接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。 另一种是直接通过controller接受指令。 三、实例：Backbone实际项目往往采用更灵活的方式，以 Backbone.js 为例。 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。 Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。 四、MVPMVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。 各部分之间的通信，都是双向的。 View 与 Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。 五、MVVMMVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。 转载www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"MVC","slug":"MVC","permalink":"https://forevehg.github.io/tags/MVC/"},{"name":"MVP","slug":"MVP","permalink":"https://forevehg.github.io/tags/MVP/"},{"name":"MVVM","slug":"MVVM","permalink":"https://forevehg.github.io/tags/MVVM/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"Node学习笔记","slug":"Node学习笔记","date":"2017-01-20T07:25:49.000Z","updated":"2020-05-17T15:12:07.000Z","comments":true,"path":"2017/01/20/Node学习笔记/","link":"","permalink":"https://forevehg.github.io/2017/01/20/Node学习笔记/","excerpt":"1.exports和module.exports的区别： module.exports的初始值是一个空对象{}; exports指向module.exports require()返回的module.exports而不是exports","text":"1.exports和module.exports的区别： module.exports的初始值是一个空对象{}; exports指向module.exports require()返回的module.exports而不是exports2.express中的中间件：所谓中间件，就是在收到请求后和发送响应之前这个阶段执行的一些函数。参考这篇博客，写的非常好，通俗易懂http://blog.csdn.net/foruok/article/details/47354737","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://forevehg.github.io/tags/Node/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"Sublime Text3 手动配置Nodejs环境","slug":"Sublime3-配置nodejs环境","date":"2017-01-20T03:30:15.000Z","updated":"2020-05-17T15:14:44.000Z","comments":true,"path":"2017/01/20/Sublime3-配置nodejs环境/","link":"","permalink":"https://forevehg.github.io/2017/01/20/Sublime3-配置nodejs环境/","excerpt":"用了几天命令行，感觉挺麻烦的，因为常用sublime3开发，就想能不能在sublime3中配置一个运行nodejs的环境，果然有很多这方面的教程，参考后手动配置了nodejs环境，下面是配置过程：","text":"用了几天命令行，感觉挺麻烦的，因为常用sublime3开发，就想能不能在sublime3中配置一个运行nodejs的环境，果然有很多这方面的教程，参考后手动配置了nodejs环境，下面是配置过程：1.首先在github上下载该包解压后放到sublimeText3的Packages目录下 2.接下来修改配置文件，打开刚才复制进去的文件夹中，找到Nodejs.sublime-settings文件，打开后修改两个地方：&quot;node_command&quot;&quot;npm_command&quot;修改后文件中的代码： { // save before running commands &quot;save_first&quot;: true, // if present, use this command instead of plain &quot;node&quot; // e.g. &quot;/usr/bin/node&quot; or &quot;C:\\bin\\node.exe&quot; &quot;node_command&quot;: &quot;D:\\\\Program Files\\\\nodejs\\\\node.exe&quot; , // Same for NPM command &quot;npm_command&quot;: &quot;D:\\\\Program Files\\\\nodejs\\\\npm.cmd&quot;, // as &#39;NODE_PATH&#39; environment variable for node runtime &quot;node_path&quot;: false, &quot;expert_mode&quot;: false, &quot;ouput_to_new_tab&quot;: false } 同样，在这个文件夹中找到Nodejs.sublime-build文件，打开修改两个地方：第一：&quot;encoding&quot;: &quot;utf8&quot;第二：”windows”中的&quot;cmd&quot;: [&quot;taskkill&quot;,&quot;/F&quot;, &quot;/IM&quot;, &quot;node.exe&quot;,&quot;&amp;&quot;,&quot;node&quot;, &quot;$file&quot;] { &quot;cmd&quot;: [&quot;node&quot;, &quot;$file&quot;], &quot;file_regex&quot;: &quot;^[ ]*File \\&quot;(...*?)\\&quot;, line ([0-9]*)&quot;, &quot;selector&quot;: &quot;source.js&quot;, &quot;shell&quot;:true, &quot;encoding&quot;: &quot;utf8&quot;, &quot;windows&quot;: { &quot;cmd&quot;: [&quot;taskkill&quot;,&quot;/F&quot;, &quot;/IM&quot;, &quot;node.exe&quot;,&quot;&amp;&quot;,&quot;node&quot;, &quot;$file&quot;] }, &quot;linux&quot;: { &quot;cmd&quot;: [&quot;killall node; node $file&quot;] }, &quot;osx&quot;: { &quot;cmd&quot;: [&quot;killall node; node $file&quot;] } } 3.测试新建一个test.js文件，输入console.log(&quot;success!&quot;)Ctrl+B编译一下，就能看到输出的内容","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://forevehg.github.io/tags/Node/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"NodeJs小问题：express不是内部或外部命令","slug":"NodeJs小问题：express不是内部或外部命令","date":"2017-01-20T02:27:10.000Z","updated":"2020-05-17T15:12:12.000Z","comments":true,"path":"2017/01/20/NodeJs小问题：express不是内部或外部命令/","link":"","permalink":"https://forevehg.github.io/2017/01/20/NodeJs小问题：express不是内部或外部命令/","excerpt":"1.nodejs安装之后就需要安装express,使用熟悉的npm install -g express命令安装,但是,安装成功之后居然提示express不是内部或外部命令.","text":"1.nodejs安装之后就需要安装express,使用熟悉的npm install -g express命令安装,但是,安装成功之后居然提示express不是内部或外部命令. 为什么会这样子呢?当我们找到安装后的express目录发现比之前熟悉的express少了很多东西,原来,最新express4.0版本中将命令工具分家出来了项目地址,所以我们还需要安装一个命令工具,命令如下: npm install -g express-generator 3.既然安装好了我们就要测试一下新安装的express到底可不可以使用于是我使用express创建一个工程: express helloworld 新版本中命令发生了一些改变, 创建好project之后还需要用npm进行添加依赖和启动: cd helloworld npm install npm start 然后新创建的helloworld就已经运行在3000端口上. 4.访问http://localhost:3000/就看到熟悉的页面了 5.以及创建出来的目录效果 转载：http://www.cnblogs.com/wmkf/articles/3913215.html","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://forevehg.github.io/tags/Node/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"NodeJs入门案例","slug":"NodeJs入门案例","date":"2017-01-01T08:00:03.000Z","updated":"2020-05-17T15:12:10.000Z","comments":true,"path":"2017/01/01/NodeJs入门案例/","link":"","permalink":"https://forevehg.github.io/2017/01/01/NodeJs入门案例/","excerpt":"刚开始接触nodejs，看了nodejs入门指南，根据上面的例子实现了一个特别简单的图片上传功能.文件目录：nodeTest–index.js","text":"刚开始接触nodejs，看了nodejs入门指南，根据上面的例子实现了一个特别简单的图片上传功能.文件目录：nodeTest–index.js–server.js–route.js–requestHandlers.js 下面是代码： &lt;!--index.js--&gt; var server = require(&#39;./server&#39;); var route = require(&#39;./route&#39;); var requestHandlers = require(&#39;./requestHandlers&#39;); var handle = {} handle[&quot;/&quot;] = requestHandlers.start; handle[&quot;/start&quot;] = requestHandlers.start; handle[&quot;/upload&quot;] = requestHandlers.upload; handle[&quot;/show&quot;] = requestHandlers.show; server.start(route.route,handle); &lt;!--server.js--&gt; var http = require(&quot;http&quot;); var url = require(&quot;url&quot;); function start(route,handle){ http.createServer(function(request,response){ var pathname = url.parse(request.url).pathname; console.log(&quot;Request for &quot;+pathname+&quot; received.&quot;); route(pathname,handle,response,request); }).listen(8888); console.log(&quot;Server has started.&quot;); } exports.start=start; &lt;!--route.js--&gt; function route(pathname,handle,response,request){ console.log(pathname,handle); if(typeof handle[pathname] === &#39;function&#39;){ return handle[pathname](response,request); }else{ console.log(&quot;No reuest handle found for &quot;+pathname) response.writeHead(404,{&quot;Content-Type&quot;:&quot;text/plain; charset=&#39;utf-8&#39;&quot;}); response.write(&quot;404 Not Found&quot;); } } exports.route = route; &lt;!--srequestHandlers--&gt; var exec = require(&quot;child_process&quot;).exec; var querystring = require(&quot;querystring&quot;); var formidable = require(&quot;formidable&quot;); var fs = require(&quot;fs&quot;); var util = require(&quot;util&quot;); function start(response,request){ console.log(&quot;Request handler &#39;start&#39; was called&quot;); var body = &#39;&lt;html&gt;&#39;+ &#39;&lt;head&gt;&#39;+ &#39;&lt;meta http-equiv=&quot;Content-Type&quot; &#39;+ &#39;content=&quot;text/html; charset=UTF-8&quot; /&gt;&#39;+ &#39;&lt;/head&gt;&#39;+ &#39;&lt;body&gt;&#39;+ &#39;&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; &#39;+ &#39;method=&quot;post&quot;&gt;&#39;+ &#39;&lt;input type=&quot;file&quot; name=&quot;upload&quot;&gt;&#39;+ &#39;&lt;input type=&quot;submit&quot; value=&quot;Upload file&quot; /&gt;&#39;+ &#39;&lt;/form&gt;&#39;+ &#39;&lt;/body&gt;&#39;+ &#39;&lt;/html&gt;&#39;; response.writeHead(200,{&quot;Content-Type&quot;:&quot;text/html&quot;}); response.write(body); response.end(); } function upload(response,request){ console.log(&quot;Request handler &#39;upload&#39; was called&quot;); var form = new formidable.IncomingForm(); form.uploadDir = &quot;G:\\\\tmp&quot;; console.log(&quot;abliut to parse&quot;); form.parse(request,function(error,fields,files){ console.log(&quot;parsing done&quot;); fs.renameSync(files.upload.path,&quot;G:\\\\tmp\\\\test.png&quot;); response.writeHead(200,{&quot;Content-Type&quot;:&quot;text/html&quot;}); response.write(&quot;received image:&lt;br/&gt;&quot;); response.write(&quot;&lt;img src=&#39;/show&#39; /&gt;&quot;); response.end(); }); } function show(response){ console.log(&quot;Request handler &#39;show&#39; was called&quot;); fs.readFile(&quot;G:\\\\tmp\\\\test.png&quot;,&quot;binary&quot;,function(error,file){ if(error){ response.writeHead(500,{&quot;Content-Type&quot;:&quot;text/plain&quot;}); response.write(error+&quot;\\n&quot;); response.end(); }else{ response.writeHead(200,{&quot;Content-Type&quot;:&quot;image/png&quot;}); response.write(file,&quot;binary&quot;); response.end(); } }) } exports.start = start; exports.upload = upload; exports.show = show; 踩坑：1.","categories":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://forevehg.github.io/tags/Node/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://forevehg.github.io/categories/技术/"}]},{"title":"Markdown语法学习","slug":"Markdown语法学习","date":"2016-12-31T07:08:53.000Z","updated":"2020-07-01T09:32:39.214Z","comments":true,"path":"2016/12/31/Markdown语法学习/","link":"","permalink":"https://forevehg.github.io/2016/12/31/Markdown语法学习/","excerpt":"基础语法1 标题示例一级标题 === 二级标题 --- # 一级标题 ## 二级标题 ### 三级标题 ...","text":"基础语法1 标题示例一级标题 === 二级标题 --- # 一级标题 ## 二级标题 ### 三级标题 ... 2 列表无序列表示例&lt;!-- 无序列表,这三种写法效果相同 --&gt; * 红 * 绿 * 蓝 + 红 + 绿 + 蓝 - 红 - 绿 - 蓝 效果 红 绿 蓝 红 绿 蓝 红 绿 蓝 有序列表示例&lt;!-- 有序列表 --&gt; 1. 红 2. 绿 3. 蓝 &lt;!-- 列表项目包含段落 --&gt; 1. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. 2. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. 效果 红 绿 蓝 This is a list item with two paragraphs. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Aliquam hendreritmi posuere lectus. This is a list item with two paragraphs. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Aliquam hendreritmi posuere lectus. 3 代码3.1 代码行在Markdown中建立代码区块非常简单，只需要一个制表符或者四个空格,显示时制表符和空格会自动删除。 示例` 使用四个空格生成代码行` 效果使用四个空格生成代码行 3.2 代码块我们可以使用一个`包裹行内代码块，使用三个`包裹多行代码块。 行内代码块示例`使用一个反引号生成行内代码块` 效果使用一个反引号生成行内代码块 多行代码块示例```function test(){ alert(“test”);}``` 效果function test(){ alert(&quot;test&quot;); } 4 引用如果需要引用别处的句子可以用&gt;符号 示例&gt; 春眠不觉晓 &gt; 处处闻啼鸟 &gt;&gt; 夜来风雨声 &gt;&gt; 花落知多少 效果 春眠不觉晓处处闻啼鸟 夜来风雨声花落知多少 5 链接markdow有两种形式的链接：行内式和参考式 行内式[要显示的链接名](连接地址 &quot;鼠标移上去显示的title&quot;); 示例这是一个[百度](http://www.baidu.com &quot;百度&quot;)行内链接 效果这是一个百度行内链 同一主机如果要链接到同一主机的资源，你可以使用相对路径 示例链接到主机[关于我](/aubout/)使用相对路径 效果链接到主机关于我使用相对路径 参考式使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断. 示例&lt;!--这是一个[百度][id]参考式链接--&gt; [id]: http://www.baidu.com 效果这是一个[百度][id]参考式链接[id]: http://www.baidu.com 自动链接用&lt;&gt;括起来，就会自动转换成链接。 示例&lt;http://www.baidu.com/&gt; 效果http://www.baidu.com/ 6 强调Markdown 使用星号（）和底线（_）作为标记强调字词的符号,被 或 _ 包围的字词会被转成用 标签包围,用两个 *或_包起来的话，则会被转成 标签。 示例&lt;!-- 斜体 --&gt; *我会被转成em标签* _me too_ &lt;!-- 粗体 --&gt; **我会被转成strong标签** __me to__ 效果我会被转成em标签me too 我会被转成strong标签me to 注：如果要插入普通的星号和下划线可以使用反斜线* 和反斜线 _,Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 符号 代码 效果 \\ \\\\ \\ ` \\` ` * \\* * _ \\_ _ { \\{ { [ \\[ [ ( \\( ( # \\# # + \\+ + - \\- - . \\. . ! \\! ! 特殊字符转换&lt;!-- 普通星号和反斜线 --&gt; \\* \\_ 7 分割线示例*** * * * - - - 效果 8 图片Markdown 使用和链接很相似的语法来标记图片，同样也允许两种样式：行内式和参考式。 行内式的图片示例![头像](/images/avatar.gif) ![头像](/images/avatar.gif &quot;Optional title&quot;) 效果详细叙述如下：一个叹号 ! 接着一个方括号[]，里面放上图片的替代文字(alt)接着一个普通括号()，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 文字。 ![name][id] 「id」是图片参考的名称，图片参考的定义方式则和连结参考一样： 参考式图片示例![头像][id] [id]: /images/avatar.gif &quot;Optional title attribute&quot; 效果![头像][id][id]: /images/avatar.gif “Optional title attribute”到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 标签。 踩坑1.标题后面必须加一个空格。2.必须按照标题大小的顺序写才能正确的生成目录，如果大标题用#,小标题直接用###目录会混乱，用#后接下来应该用##才会准确的生成文章目录。3.生成表格前要加一个空行 补充markdown中使用echarts在markdown中使用echarts，有已经写好的hexo插件，直接拿来用 npm install hexo-tag-charts3 --save 这个插件似乎已经很久不更新了，插件中的echarts版本比较旧，下载到项目之后，可以手动的进行echarts版本更新，进入项目的node_modules/hexo-tag-echarts3/template.html中，将echarts的引用版本替换成新版echarts即可，我用的bootstrap的cdn，https://cdn.bootcdn.net/ajax/libs/echarts/4.8.0/echarts-en.common.js markdown中引用变量","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://forevehg.github.io/categories/博客搭建/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://forevehg.github.io/tags/Markdown/"},{"name":"hexo","slug":"hexo","permalink":"https://forevehg.github.io/tags/hexo/"}],"keywords":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://forevehg.github.io/categories/博客搭建/"}]}]}